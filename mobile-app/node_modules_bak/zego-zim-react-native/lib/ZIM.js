import { ZIMConversationType, } from './ZIMDefines';
import { ZIMManager } from './impl/ZIMManager';
import { NotInitError } from './impl/ZIMParamValid';
export default class ZIM {
    constructor(engine) {
        if (!engine)
            throw new Error('Can not be use new.');
        this.engine = engine;
    }
    static setLogConfig(config) {
        ZIMManager.getInstance().setLogConfig(config);
    }
    static setCacheConfig(config) {
        ZIMManager.getInstance().setCacheConfig(config);
    }
    static setAdvancedConfig(key, value) {
        ZIMManager.getInstance().setAdvancedConfig(key, value);
    }
    static setGeofencingConfig(areaList, type) {
        return ZIMManager.getInstance().setGeofencingConfig(areaList, type);
    }
    /**
     * Gets the SDK's version number.
     *
     * When the SDK is running, the developer finds that it does not match the expected situation and submits the problem and related logs to the ZEGO technical staff for locating. The ZEGO technical staff may need the information of the engine version to assist in locating the problem.
     * Developers can also collect this information as the version information of the engine used by the app, so that the SDK corresponding to each version of the app on the line.
     * @return {string} - SDK version
     */
    static getVersion() {
        return ZIMManager.getInstance().getVersion();
    }
    static create(appConfig) {
        const appID = typeof appConfig == 'object' ? appConfig.appID : appConfig;
        const appSign = typeof appConfig == 'object' ? appConfig.appSign : '';
        const engine = ZIMManager.getInstance().createEngine(appID, appSign);
        if (engine) {
            ZIM._instatance = new ZIM(engine);
            return ZIM._instatance;
        }
        return null;
    }
    static getInstance() {
        return ZIM._instatance;
    }
    destroy() {
        ZIMManager.getInstance().destroyEngine(this.engine);
        // @ts-ignore
        this.engine = null;
        ZIM._instatance = null;
    }
    on(type, listener) {
        this.engine && this.engine.on(type, listener);
    }
    off(type) {
        this.engine && this.engine.off(type);
    }
    uploadLog() {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.uploadLog();
    }
    // MARK: - Main
    login(userID, config) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.login(
        // @ts-ignore
        typeof userID == 'object' ? userID.userID : userID, typeof config == 'object'
            ? config
            : {
                // @ts-ignore
                userName: typeof userID == 'object' ? userID.userName : '',
                customStatus: '',
                token: config,
                isOfflineLogin: false,
            });
    }
    logout() {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.logout();
    }
    renewToken(token) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.renewToken(token);
    }
    updateUserName(userName) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.updateUserName(userName);
    }
    updateUserAvatarUrl(userAvatarUrl) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.updateUserAvatarUrl(userAvatarUrl);
    }
    updateUserExtendedData(extendedData) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.updateUserExtendedData(extendedData);
    }
    updateUserCustomStatus(customStatus) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.updateUserCustomStatus(customStatus);
    }
    updateUserOfflinePushRule(offlinePushRule) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.updateUserOfflinePushRule(offlinePushRule);
    }
    queryUsersInfo(userIDs, config) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.queryUsersInfo(userIDs, config);
    }
    querySelfUserInfo() {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.querySelfUserInfo();
    }
    queryLocalFileCache(config) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.queryLocalFileCache(config);
    }
    clearLocalFileCache(config) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.clearLocalFileCache(config);
    }
    subscribeUsersStatus(userIDs, config) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.subscribeUsersStatus(true, userIDs, config);
    }
    unsubscribeUsersStatus(userIDs) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.subscribeUsersStatus(false, userIDs);
    }
    queryUsersStatus(userIDs) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.queryUsersStatus(userIDs);
    }
    querySubscribedUserStatusList(config) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.querySubscribedUsersStatus(config);
    }
    // MARK: - Conversation
    queryConversation(conversationID, conversationType) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.queryConversation(conversationID, conversationType);
    }
    queryConversationList(config, option) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.queryConversationList(config, option);
    }
    queryConversationPinnedList(config) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.queryConversationPinnedList(config);
    }
    queryConversationTotalUnreadMessageCount(config) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.queryConversationTotalUnreadMessageCount(config);
    }
    deleteConversation(conversationID, conversationType, config) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.deleteConversation(conversationID, conversationType, config);
    }
    deleteAllConversations(config) {
        return this.engine.deleteAllConversations(config);
    }
    updateConversationPinnedState(isPinned, conversationID, conversationType) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.updateConversationPinnedState(isPinned, conversationID, conversationType);
    }
    setConversationNotificationStatus(status, conversationID, conversationType) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.setConversationNotificationStatus(status, conversationID, conversationType);
    }
    setConversationDraft(draft, conversationID, conversationType) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.setConversationDraft(draft, conversationID, conversationType);
    }
    setConversationMark(markType, enable, conversationInfos) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.setConversationMark(markType, enable, conversationInfos);
    }
    clearConversationUnreadMessageCount(conversationID, conversationType) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.clearConversationUnreadMessageCount(conversationID, conversationType);
    }
    clearConversationTotalUnreadMessageCount() {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.clearConversationTotalUnreadMessageCount();
    }
    deleteAllConversationMessages(config) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.deleteAllConversationMessages(config);
    }
    /**
     * @deprecated
     * Deprecated since 2.4.0, please use [sendMessage].
     */
    sendPeerMessage(message, toUserID, config) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.sendMessage(message, toUserID, ZIMConversationType.Peer, config);
    }
    /**
     * @deprecated
     * Deprecated since 2.4.0, please use [sendMessage].
     */
    sendGroupMessage(message, toGroupID, config) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.sendMessage(message, toGroupID, ZIMConversationType.Group, config);
    }
    /**
     * @deprecated
     * Deprecated since 2.4.0, please use [sendMessage].
     */
    sendRoomMessage(message, toRoomID, config) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.sendMessage(message, toRoomID, ZIMConversationType.Room, config);
    }
    /**
     * @deprecated
     * Deprecated since 2.19.0, please use [sendMessage].
     */
    sendMediaMessage(message, toConversationID, conversationType, config, notification) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.sendMessage(message, toConversationID, conversationType, config, notification);
    }
    sendMessage(message, toConversationID, conversationType, config, notification) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.sendMessage(message, toConversationID, conversationType, config, notification);
    }
    editMessage(message, config, notification) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.editMessage(message, notification);
    }
    deleteMessages(messageList, conversationID, conversationType, config) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.deleteMessages(messageList, conversationID, conversationType, config);
    }
    deleteAllMessage(conversationID, conversationType, config) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.deleteAllMessage(conversationID, conversationType, config);
    }
    queryHistoryMessage(conversationID, conversationType, config) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.queryHistoryMessage(conversationID, conversationType, config);
    }
    downloadMediaFile(message, fileType, config, progress) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        const _config = typeof config == 'function' ? { messageInfoIndex: 0 } : config;
        const _progress = typeof config == 'function' ? config : progress;
        return this.engine.downloadMediaFile(message, fileType, _config, _progress);
    }
    importLocalMessages(folderPath, config, progress) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.importLocalMessages(folderPath, config, progress);
    }
    exportLocalMessages(folderPath, config, progress) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.exportLocalMessages(folderPath, config, progress);
    }
    insertMessageToLocalDB(message, conversationID, conversationType, senderUserID) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.insertMessageToLocalDB(message, conversationID, conversationType, senderUserID);
    }
    updateMessageLocalExtendedData(localExtendedData, message) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.updateMessageLocalExtendedData(localExtendedData, message);
    }
    cancelSendingMessage(message, config) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.cancelSendingMessage(message, config);
    }
    revokeMessage(message, config) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.revokeMessage(message, config);
    }
    queryCombineMessageDetail(message) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.queryCombineMessageDetail(message);
    }
    pinMessage(message, isPinned) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.pinMessage(message, isPinned);
    }
    queryPinnedMessageList(conversationID, conversationType) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.queryPinnedMessageList(conversationID, conversationType);
    }
    // MARK: - Message receipt
    sendConversationMessageReceiptRead(conversationID, conversationType) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.sendConversationMessageReceiptRead(conversationID, conversationType);
    }
    sendMessageReceiptsRead(messageList, conversationID, conversationType) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.sendMessageReceiptsRead(messageList, conversationID, conversationType);
    }
    queryMessageReceiptsInfo(messageList, conversationID, conversationType) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.queryMessageReceiptsInfo(messageList, conversationID, conversationType);
    }
    queryGroupMessageReceiptReadMemberList(message, groupID, config) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.queryGroupMessageReceiptMemberList(message, groupID, config, true);
    }
    queryGroupMessageReceiptUnreadMemberList(message, groupID, config) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.queryGroupMessageReceiptMemberList(message, groupID, config, false);
    }
    // MARK: - Message reaction
    addMessageReaction(reactionType, message) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.addMessageReaction(reactionType, message);
    }
    deleteMessageReaction(reactionType, message) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.deleteMessageReaction(reactionType, message);
    }
    queryMessageReactionUserList(message, config) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.queryMessageReactionUserList(message, config);
    }
    // MARK: - Message reply
    replyMessage(message, toOriginalMessage, config, notification) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.replyMessage(message, toOriginalMessage, config, notification);
    }
    queryMessageRepliedList(message, config) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.queryMessageRepliedList(message, config);
    }
    queryMessages(messageSeqs, conversationID, conversationType) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.queryMessages(messageSeqs, conversationID, conversationType);
    }
    // MARK: - Room
    createRoom(roomInfo, config) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.createRoom(roomInfo, config);
    }
    enterRoom(roomInfo, config) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.enterRoom(roomInfo, config);
    }
    joinRoom(roomID) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.joinRoom(roomID);
    }
    switchRoom(fromRoomID, toRoomInfo, isCreateWhenRoomNotExisted, config) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.switchRoom(fromRoomID, toRoomInfo, isCreateWhenRoomNotExisted, config);
    }
    leaveRoom(roomID) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.leaveRoom(roomID);
    }
    leaveAllRoom() {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.leaveAllRoom();
    }
    queryRoomMemberList(roomID, config) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.queryRoomMemberList(roomID, config);
    }
    queryRoomMembers(userIDs, roomID) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.queryRoomMembers(userIDs, roomID);
    }
    queryRoomOnlineMemberCount(roomID) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.queryRoomOnlineMemberCount(roomID);
    }
    queryRoomAllAttributes(roomID) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.queryRoomAllAttributes(roomID);
    }
    setRoomAttributes(roomAttributes, roomID, config) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.setRoomAttributes(roomAttributes, roomID, config);
    }
    deleteRoomAttributes(keys, roomID, config) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.deleteRoomAttributes(keys, roomID, config);
    }
    beginRoomAttributesBatchOperation(roomID, config) {
        this.engine && this.engine.beginRoomAttributesBatchOperation(roomID, config);
    }
    endRoomAttributesBatchOperation(roomID) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.endRoomAttributesBatchOperation(roomID);
    }
    setRoomMembersAttributes(attributes, userIDs, roomID, config) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.setRoomMembersAttributes(attributes, userIDs, roomID, config);
    }
    queryRoomMembersAttributes(userIDs, roomID) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.queryRoomMembersAttributes(userIDs, roomID);
    }
    queryRoomMemberAttributesList(roomID, config) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.queryRoomMemberAttributesList(roomID, config);
    }
    // MARK: - Group
    createGroup(groupInfo, userIDs, config) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.createGroup(groupInfo, userIDs, config);
    }
    joinGroup(groupID) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.joinGroup(true, groupID);
    }
    leaveGroup(groupID) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.leaveGroup(groupID);
    }
    dismissGroup(groupID) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.dismissGroup(groupID);
    }
    queryGroupList(count, config) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.queryGroupList(count || 0, config);
    }
    updateGroupName(groupName, groupID) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.updateGroupName(groupName, groupID);
    }
    updateGroupNotice(groupNotice, groupID) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.updateGroupNotice(groupNotice, groupID);
    }
    updateGroupAvatarUrl(groupAvatarUrl, groupID) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.updateGroupAvatarUrl(groupAvatarUrl, groupID);
    }
    muteGroup(isMute, groupID, config) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.muteGroup(isMute, groupID, config);
    }
    queryGroupInfo(groupID) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.queryGroupInfo(groupID);
    }
    setGroupAttributes(groupAttributes, groupID) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.setGroupAttributes(groupAttributes, groupID);
    }
    deleteGroupAttributes(keys, groupID) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.deleteGroupAttributes(keys, groupID);
    }
    queryGroupAttributes(keys, groupID) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.queryGroupAttributes(keys, groupID);
    }
    queryGroupAllAttributes(groupID) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.queryGroupAllAttributes(groupID);
    }
    updateGroupAlias(groupAlias, groupID) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.updateGroupAlias(groupAlias, groupID);
    }
    setGroupMemberNickname(nickname, forUserID, groupID) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.setGroupMemberNickname(nickname, forUserID, groupID);
    }
    setGroupMemberRole(role, forUserID, groupID) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.setGroupMemberRole(role, forUserID, groupID);
    }
    transferGroupOwner(toUserID, groupID) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.transferGroupOwner(toUserID, groupID);
    }
    queryGroupMemberInfo(userID, groupID) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.queryGroupMemberInfo(userID, groupID);
    }
    inviteUsersIntoGroup(userIDs, groupID) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.inviteUsersIntoGroup(false, userIDs, groupID);
    }
    kickGroupMembers(userIDs, groupID) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.kickGroupMembers(userIDs, groupID);
    }
    queryGroupMemberList(groupID, config) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.queryGroupMemberList(groupID, config);
    }
    queryGroupMemberCount(groupID) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.queryGroupMemberCount(groupID);
    }
    muteGroupMembers(isMute, userIDs, groupID, config) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.muteGroupMembers(isMute, userIDs, groupID, config);
    }
    queryGroupMemberMutedList(groupID, config) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.queryGroupMemberMutedList(groupID, config);
    }
    updateGroupJoinMode(mode, groupID) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.updateGroupVerifyMode(mode, groupID, 0);
    }
    updateGroupInviteMode(mode, groupID) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.updateGroupVerifyMode(mode, groupID, 1);
    }
    updateGroupBeInviteMode(mode, groupID) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.updateGroupVerifyMode(mode, groupID, 2);
    }
    sendGroupJoinApplication(groupID, config) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.joinGroup(false, groupID, config);
    }
    acceptGroupJoinApplication(userID, groupID, config) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.acceptGroupApply(true, userID, groupID, config);
    }
    rejectGroupJoinApplication(userID, groupID, config) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.rejectGroupApply(true, userID, groupID, config);
    }
    sendGroupInviteApplications(userIDs, groupID, config) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.inviteUsersIntoGroup(true, userIDs, groupID, config);
    }
    acceptGroupInviteApplication(inviterUserID, groupID, config) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.acceptGroupApply(false, inviterUserID, groupID, config);
    }
    rejectGroupInviteApplication(inviterUserID, groupID, config) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.rejectGroupApply(false, inviterUserID, groupID, config);
    }
    queryGroupApplicationList(config) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.queryGroupApplyList(config);
    }
    // MARK: - Call
    callInvite(invitees, config) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.callInvite(invitees, config);
    }
    callCancel(invitees, callID, config) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.callCancel(invitees, callID, config);
    }
    callAccept(callID, config) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.callAccept(callID, config);
    }
    callReject(callID, config) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.callReject(callID, config);
    }
    callQuit(callID, config) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.callQuit(callID, config);
    }
    callEnd(callID, config) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.callEnd(callID, config);
    }
    callJoin(callID, config) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.callJoin(callID, config);
    }
    callingInvite(invitees, callID, config) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.callingInvite(invitees, callID, config);
    }
    queryCallInvitationList(config) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.queryCallInvitationList(config);
    }
    // MARK: - DB Search
    searchLocalConversations(config) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.searchConversations(config);
    }
    searchGlobalLocalMessages(config) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.searchGlobalMessages(config);
    }
    searchLocalMessages(conversationID, conversationType, config) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.searchMessages(conversationID, conversationType, config);
    }
    searchLocalGroups(config) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.searchGroups(config);
    }
    searchLocalGroupMembers(groupID, config) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.searchGroupMembers(groupID, config);
    }
    searchLocalFriends(config) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.searchFriends(config);
    }
    // MARK: - Friend
    addFriend(userID, config) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.addFriend(userID, config);
    }
    sendFriendApplication(userID, config) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.sendFriendApplication(userID, config);
    }
    deleteFriends(userIDs, config) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.deleteFriends(userIDs, config);
    }
    checkFriendsRelation(userIDs, config) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.checkFriendsRelation(userIDs, config);
    }
    updateFriendAlias(friendAlias, userID) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.updateFriendAlias(friendAlias, userID);
    }
    updateFriendAttributes(friendAttributes, userID) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.updateFriendAttributes(friendAttributes, userID);
    }
    acceptFriendApplication(userID, config) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.acceptFriendApplication(userID, config);
    }
    rejectFriendApplication(userID, config) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.rejectFriendApplication(userID, config);
    }
    queryFriendsInfo(userIDs) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.queryFriendsInfo(userIDs);
    }
    queryFriendList(config) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.queryFriendList(config);
    }
    queryFriendApplicationList(config) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.queryFriendApplicationList(config);
    }
    // MARK: - Blacklist
    addUsersToBlacklist(userIDs) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.addUsersToBlacklist(userIDs);
    }
    removeUsersFromBlacklist(userIDs) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.removeUsersFromBlacklist(userIDs);
    }
    checkUserIsInBlacklist(userID) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.checkUserIsInBlacklist(userID);
    }
    queryBlacklist(config) {
        if (!this.engine)
            return Promise.reject(NotInitError);
        return this.engine.queryBlacklist(config);
    }
}
ZIM._instatance = null;
