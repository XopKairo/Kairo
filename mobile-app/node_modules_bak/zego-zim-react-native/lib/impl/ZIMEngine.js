import { NativeEventEmitter, NativeModules } from 'react-native';
import { ZIMGroupMuteMode, ZIMMessageDirection, ZIMMessageType, } from '../ZIMDefines';
import { ZIMLogAction, ZIMLogTag, ZIMLogger } from './ZIMLogger';
import { ZIMManager } from './ZIMManager';
import { ZIMParamValid } from './ZIMParamValid';
const { ZIMNativeModule } = NativeModules;
const Prefix = ZIMNativeModule.prefix;
const ZIMEvent = new NativeEventEmitter(ZIMNativeModule);
const NOOP = () => { };
export function createSymbol() {
    return Symbol(Math.random().toString(16)).toString();
}
export class ZIMEngine {
    constructor(handle, appID, appSign) {
        this.loginUserID = '';
        this.handle = handle;
        this.appID = appID;
        this.appSign = appSign;
        this.logger = new ZIMLogger();
        this.paramValid = new ZIMParamValid(this.logger);
        this.messageAttachedMap = new Map();
        this.messageLoadingMap = new Map();
        this.messagePortMap = new Map();
        this.eventNameList = [
            'error',
            'connectionStateChanged',
            'tokenWillExpire',
            'userInfoUpdated',
            'userStatusUpdated',
            'userRuleUpdated',
            'conversationsAllDeleted',
            'conversationChanged',
            'conversationSyncStateChanged',
            'conversationTotalUnreadMessageCountUpdated',
            'conversationMessageReceiptChanged',
            'messageReceiptChanged',
            'messageRevokeReceived',
            'messageReactionsChanged',
            'messageRepliedCountChanged',
            'messageRepliedInfoChanged',
            'messagePinStatusChanged',
            'messageEdited',
            'messageDeleted',
            'messageSentStatusChanged',
            'broadcastMessageReceived',
            'receiveRoomMessage',
            'receivePeerMessage',
            'receiveGroupMessage',
            'roomMessageReceived',
            'peerMessageReceived',
            'groupMessageReceived',
            'messageAttachedHook',
            'messageLoadingProgress',
            'messagePortProgress',
            'roomStateChanged',
            'roomMemberJoined',
            'roomMemberLeft',
            'roomAttributesUpdated',
            'roomAttributesBatchUpdated',
            'roomMemberAttributesUpdated',
            'groupStateChanged',
            'groupNameUpdated',
            'groupAvatarUrlUpdated',
            'groupNoticeUpdated',
            'groupAliasUpdated',
            'groupAttributesUpdated',
            'groupMutedInfoUpdated',
            'groupVerifyInfoUpdated',
            'groupApplicationListChanged',
            'groupApplicationUpdated',
            'groupMemberStateChanged',
            'groupMemberInfoUpdated',
            'callInvitationCreated',
            'callInvitationReceived',
            'callInvitationCancelled',
            'callInvitationTimeout',
            'callInvitationEnded',
            'callUserStateChanged',
            'callInvitationAccepted',
            'callInvitationRejected',
            'callInviteesAnsweredTimeout',
            'blacklistChanged',
            'friendListChanged',
            'friendInfoUpdated',
            'friendApplicationListChanged',
            'friendApplicationUpdated',
        ];
        this.create();
    }
    create() {
        ZIMNativeModule.setAdvancedConfig('zim_cross_platform', 'react-native');
        ZIMNativeModule.createEngine(this.handle, this.appID, this.appSign);
    }
    handleReject(err) {
        const error = err && err.code ? { code: +err.code, message: err.message } : err;
        throw error;
    }
    convertMapToUint8Array(type, data) {
        if (type == 'receivePeerMessage' ||
            type == 'receiveGroupMessage' ||
            type == 'receiveRoomMessage' ||
            type == 'peerMessageReceived' ||
            type == 'groupMessageReceived' ||
            type == 'roomMessageReceived') {
            data.messageList.forEach((msg) => {
                if (msg.type == 2) {
                    msg.message = new Uint8Array(Object.values(msg.message));
                }
            });
        }
        else if (type == 'broadcastMessageReceived' && data.message && data.message.type == 2) {
            data.message.message = new Uint8Array(Object.values(data.message.message));
        }
        else if (type == 'messageSentStatusChanged') {
            data.infos.forEach((info) => {
                if (info.message && info.message.type == 2) {
                    info.message.message = new Uint8Array(Object.values(info.message.message));
                }
            });
        }
    }
    destroy() {
        for (const event of this.eventNameList) {
            ZIMEvent.removeAllListeners(Prefix + event);
        }
        this.messageLoadingMap.clear();
        this.messageAttachedMap.clear();
        this.messagePortMap.clear();
        ZIMNativeModule.destroyEngine(this.handle);
    }
    uploadLog() {
        return ZIMNativeModule.uploadLog(this.handle).catch(this.handleReject);
    }
    on(type, listener) {
        if (!listener || typeof listener != 'function')
            throw new Error('listener must be a function.');
        this.off(type);
        const native_listener = (res) => {
            try {
                const { handle, data } = res;
                this.convertMapToUint8Array(type, data);
                this.logger.warn('', 'JSAPI.emit.' + type, data);
                const engine = ZIMManager.engineMap.get(handle);
                // @ts-ignore
                listener(engine, data);
            }
            catch (error) { }
        };
        ZIMEvent.addListener(Prefix + type, native_listener);
        this.logger.warn('', 'JSAPI.on.' + type);
    }
    off(type) {
        ZIMEvent.removeAllListeners(Prefix + type);
    }
    // MARK: - Main
    login(userID, config) {
        const error = this.paramValid.validID('userID', userID, ZIMLogTag.User, ZIMLogAction.Login);
        if (error)
            return Promise.reject(error);
        config = Object.assign({ userName: '', token: '', isOfflineLogin: false }, config);
        return ZIMNativeModule.login(this.handle, userID, config)
            .then(() => (this.loginUserID = userID))
            .catch(this.handleReject);
    }
    logout() {
        return ZIMNativeModule.logout(this.handle).catch(this.handleReject);
    }
    renewToken(token) {
        return ZIMNativeModule.renewToken(this.handle, token).catch(this.handleReject);
    }
    updateUserName(userName) {
        const error = this.paramValid.validName('userName', userName, ZIMLogTag.User, ZIMLogAction.UpdateUserName);
        if (error)
            return Promise.reject(error);
        return ZIMNativeModule.updateUserName(this.handle, userName).catch(this.handleReject);
    }
    updateUserAvatarUrl(userAvatarUrl) {
        const error = this.paramValid.validName('userAvatarUrl', userAvatarUrl, ZIMLogTag.User, ZIMLogAction.UpdateUserAvatarUrl);
        if (error)
            return Promise.reject(error);
        return ZIMNativeModule.updateUserAvatarUrl(this.handle, userAvatarUrl).catch(this.handleReject);
    }
    updateUserExtendedData(extendedData) {
        const error = this.paramValid.validName('extendedData', extendedData, ZIMLogTag.User, ZIMLogAction.UpdateUserExtendedData);
        if (error)
            return Promise.reject(error);
        return ZIMNativeModule.updateUserExtendedData(this.handle, extendedData).catch(this.handleReject);
    }
    updateUserCustomStatus(customStatus) {
        return ZIMNativeModule.updateUserCustomStatus(this.handle, customStatus).catch(this.handleReject);
    }
    updateUserOfflinePushRule(offlinePushRule) {
        const error = this.paramValid.updateUserOfflinePushRule(offlinePushRule);
        if (error)
            return Promise.reject(error);
        return ZIMNativeModule.updateUserOfflinePushRule(this.handle, offlinePushRule).catch(this.handleReject);
    }
    queryUsersInfo(userIDs, config) {
        const error = this.paramValid.validArray('userIDs', userIDs, ZIMLogTag.User, ZIMLogAction.QueryUsersInfo);
        if (error)
            return Promise.reject(error);
        config = Object.assign({ isQueryFromServer: false }, config);
        return ZIMNativeModule.queryUsersInfo(this.handle, userIDs, config).catch(this.handleReject);
    }
    querySelfUserInfo() {
        return ZIMNativeModule.querySelfUserInfo(this.handle).catch(this.handleReject);
    }
    queryLocalFileCache(config) {
        config = Object.assign({ endTime: 0 }, config);
        return ZIMNativeModule.queryLocalFileCache(this.handle, config).catch(this.handleReject);
    }
    clearLocalFileCache(config) {
        config = Object.assign({ endTime: 0 }, config);
        return ZIMNativeModule.clearLocalFileCache(this.handle, config).catch(this.handleReject);
    }
    subscribeUsersStatus(isSub, userIDs, config) {
        let error = this.paramValid.validArray('userIDs', userIDs, ZIMLogTag.User, ZIMLogAction.SubscribeStatus);
        if (!error && isSub && (!config || !config.subscriptionDuration || config.subscriptionDuration < 1)) {
            error = { code: 6000001, message: ZIMLogAction.SubscribeStatus + ': Duration is invalid.' };
        }
        if (error)
            return Promise.reject(error);
        return ZIMNativeModule.subscribeUsersStatus(this.handle, isSub, userIDs, config ? config.subscriptionDuration || 0 : 0).catch(this.handleReject);
    }
    queryUsersStatus(userIDs) {
        const error = this.paramValid.validArray('userIDs', userIDs, ZIMLogTag.User, ZIMLogAction.QueryStatus);
        if (error)
            return Promise.reject(error);
        return ZIMNativeModule.queryUsersStatus(this.handle, userIDs).catch(this.handleReject);
    }
    querySubscribedUsersStatus(config) {
        return ZIMNativeModule.querySubscribedUsersStatus(this.handle, config ? config.userIDs || [] : []).catch(this.handleReject);
    }
    // MARK: - Conversation
    queryConversation(conversationID, conversationType) {
        const error = this.paramValid.validConvIDAndType(conversationID, conversationType, ZIMLogAction.QueryConv);
        if (error)
            return Promise.reject(error);
        return ZIMNativeModule.queryConversation(this.handle, conversationID, conversationType).catch(this.handleReject);
    }
    queryConversationList(config, option) {
        const error = this.paramValid.validCount(config, ZIMLogTag.Conversation, ZIMLogAction.QueryConvList);
        if (error)
            return Promise.reject(error);
        if (config.count < 1)
            return Promise.resolve({ conversationList: [] });
        if (config.nextConversation)
            config.nextConversation = JSON.parse(JSON.stringify(config.nextConversation));
        return ZIMNativeModule.queryConversationList(this.handle, config, option || {}).catch(this.handleReject);
    }
    queryConversationPinnedList(config) {
        const error = this.paramValid.validCount(config, ZIMLogTag.Conversation, ZIMLogAction.QueryPinnedList);
        if (error)
            return Promise.reject(error);
        if (config.count < 1)
            return Promise.resolve({ conversationList: [] });
        if (config.nextConversation)
            config.nextConversation = JSON.parse(JSON.stringify(config.nextConversation));
        return ZIMNativeModule.queryConversationPinnedList(this.handle, config).catch(this.handleReject);
    }
    queryConversationTotalUnreadMessageCount(config) {
        return ZIMNativeModule.queryConversationTotalUnreadMessageCount(this.handle, config).catch(this.handleReject);
    }
    deleteConversation(conversationID, conversationType, config) {
        const error = this.paramValid.validConvIDAndType(conversationID, conversationType, ZIMLogAction.DeleteConv);
        if (error)
            return Promise.reject(error);
        config = Object.assign({ isAlsoDeleteServerConversation: true }, config);
        return ZIMNativeModule.deleteConversation(this.handle, conversationID, conversationType, config).catch(this.handleReject);
    }
    deleteAllConversations(config) {
        config = Object.assign({ isAlsoDeleteServerConversation: true }, config);
        return ZIMNativeModule.deleteAllConversations(this.handle, config).catch(this.handleReject);
    }
    setConversationNotificationStatus(status, conversationID, conversationType) {
        const error = this.paramValid.setNotificationStatus(status, conversationID, conversationType);
        if (error)
            return Promise.reject(error);
        return ZIMNativeModule.setConversationNotificationStatus(this.handle, status, conversationID, conversationType).catch(this.handleReject);
    }
    setConversationDraft(draft, conversationID, conversationType) {
        const error = this.paramValid.setConversationDraft(conversationID, conversationType, draft);
        if (error)
            return Promise.reject(error);
        return ZIMNativeModule.setConversationDraft(this.handle, draft, conversationID, conversationType).catch(this.handleReject);
    }
    setConversationMark(markType, enable, conversationInfos) {
        const error = this.paramValid.setConvMark(markType, conversationInfos);
        if (error)
            return Promise.reject(error);
        return ZIMNativeModule.setConversationMark(this.handle, markType, !!enable, conversationInfos).catch(this.handleReject);
    }
    updateConversationPinnedState(isPinned, conversationID, conversationType) {
        const error = this.paramValid.validConvIDAndType(conversationID, conversationType, ZIMLogAction.UpdatePinnedState);
        if (error)
            return Promise.reject(error);
        return ZIMNativeModule.updateConversationPinnedState(this.handle, isPinned, conversationID, conversationType).catch(this.handleReject);
    }
    clearConversationUnreadMessageCount(conversationID, conversationType) {
        const error = this.paramValid.validConvIDAndType(conversationID, conversationType, ZIMLogAction.ClearUnreadCount);
        if (error)
            return Promise.reject(error);
        return ZIMNativeModule.clearConversationUnreadMessageCount(this.handle, conversationID, conversationType).catch(this.handleReject);
    }
    clearConversationTotalUnreadMessageCount() {
        return ZIMNativeModule.clearConversationTotalUnreadMessageCount(this.handle).catch(this.handleReject);
    }
    deleteAllConversationMessages(config) {
        config = Object.assign({ isAlsoDeleteServerMessage: true }, config);
        return ZIMNativeModule.deleteAllConversationMessages(this.handle, config).catch(this.handleReject);
    }
    sendMessage(_message, toConversationID, conversationType, config, notification) {
        const error = this.paramValid.sendMessage(_message, toConversationID, conversationType, config);
        if (error)
            return Promise.reject(error);
        config = Object.assign({ hasReceipt: false }, config);
        const message = JSON.parse(JSON.stringify(_message)); // no readonly obj
        // Uint8Array -> Array<number>
        const u8Arr = message.type == ZIMMessageType.Command ? _message.message : void 0;
        if (u8Arr)
            message.message = Array.from(u8Arr);
        const _handle = createSymbol();
        let progress_sub = null;
        if (message.type >= ZIMMessageType.Multiple && message.type <= ZIMMessageType.Video) {
            const progressCallBack = (notification &&
                notification[message.type == ZIMMessageType.Multiple
                    ? 'onMultipleMediaUploadingProgress'
                    : 'onMediaUploadingProgress']) ||
                NOOP;
            const native_progress_listener = (res) => {
                const { handle, data } = res;
                if (handle == _handle) {
                    const listener = this.messageLoadingMap.get(handle);
                    // @ts-ignore
                    listener && listener(...data);
                }
            };
            progress_sub = ZIMEvent.addListener(Prefix + 'messageLoadingProgress', native_progress_listener);
            this.messageLoadingMap.set(_handle, progressCallBack);
        }
        const messageAttachedCallBack = (notification && notification.onMessageAttached) || NOOP;
        const native_messageAttached_listener = (res) => {
            const { handle, data } = res;
            if (handle == _handle) {
                if (u8Arr)
                    data[0].message = u8Arr;
                const listener = this.messageAttachedMap.get(handle);
                listener && listener(data[0]);
            }
        };
        const attached_sub = ZIMEvent.addListener(Prefix + 'messageAttachedHook', native_messageAttached_listener);
        this.messageAttachedMap.set(_handle, messageAttachedCallBack);
        return ZIMNativeModule.sendMessage(this.handle, message, toConversationID, conversationType, config, _handle)
            .then((result) => {
            progress_sub && progress_sub.remove();
            attached_sub.remove();
            this.messageLoadingMap.delete(_handle);
            this.messageAttachedMap.delete(_handle);
            if (u8Arr)
                result.message.message = u8Arr;
            return result;
        })
            .catch((err) => {
            progress_sub && progress_sub.remove();
            attached_sub.remove();
            this.messageLoadingMap.delete(_handle);
            this.messageAttachedMap.delete(_handle);
            this.handleReject(err);
        });
    }
    replyMessage(_message, toOriginalMessage, config, notification) {
        const error = this.paramValid.replyMsg(_message, toOriginalMessage, config);
        if (error)
            return Promise.reject(error);
        config = Object.assign({ hasReceipt: false }, config);
        const _handle = createSymbol();
        const message = JSON.parse(JSON.stringify(_message)); // no readonly obj
        let progress_sub = null;
        if (message.type >= ZIMMessageType.Multiple && message.type <= ZIMMessageType.Video) {
            const progressCallBack = (notification &&
                notification[message.type == ZIMMessageType.Multiple
                    ? 'onMultipleMediaUploadingProgress'
                    : 'onMediaUploadingProgress']) ||
                NOOP;
            const native_progress_listener = (res) => {
                const { handle, data } = res;
                if (handle == _handle) {
                    const listener = this.messageLoadingMap.get(handle);
                    // @ts-ignore
                    listener && listener(...data);
                }
            };
            progress_sub = ZIMEvent.addListener(Prefix + 'messageLoadingProgress', native_progress_listener);
            this.messageLoadingMap.set(_handle, progressCallBack);
        }
        const messageAttachedCallBack = (notification && notification.onMessageAttached) || NOOP;
        const native_messageAttached_listener = (res) => {
            const { handle, data } = res;
            if (handle == _handle) {
                const listener = this.messageAttachedMap.get(handle);
                listener && listener(data[0]);
            }
        };
        const attached_sub = ZIMEvent.addListener(Prefix + 'messageAttachedHook', native_messageAttached_listener);
        this.messageAttachedMap.set(_handle, messageAttachedCallBack);
        return ZIMNativeModule.replyMessage(this.handle, message, { ...toOriginalMessage }, config, _handle)
            .then((result) => {
            progress_sub && progress_sub.remove();
            attached_sub.remove();
            this.messageLoadingMap.delete(_handle);
            this.messageAttachedMap.delete(_handle);
            return result;
        })
            .catch((err) => {
            progress_sub && progress_sub.remove();
            attached_sub.remove();
            this.messageLoadingMap.delete(_handle);
            this.messageAttachedMap.delete(_handle);
            this.handleReject(err);
        });
    }
    editMessage(_message, notification) {
        const error = this.paramValid.editMessage(_message);
        if (error)
            return Promise.reject(error);
        const message = JSON.parse(JSON.stringify(_message)); // no readonly obj
        const _handle = createSymbol();
        let progress_sub = null;
        if (message.type == ZIMMessageType.Multiple) {
            const progressCallBack = (notification && notification.onMultipleMediaUploadingProgress) || NOOP;
            const native_progress_listener = (res) => {
                const { handle, data } = res;
                if (handle == _handle) {
                    const listener = this.messageLoadingMap.get(handle);
                    // @ts-ignore
                    listener && listener(...data);
                }
            };
            progress_sub = ZIMEvent.addListener(Prefix + 'messageLoadingProgress', native_progress_listener);
            this.messageLoadingMap.set(_handle, progressCallBack);
        }
        const messageAttachedCallBack = (notification && notification.onMessageAttached) || NOOP;
        const native_messageAttached_listener = (res) => {
            const { handle, data } = res;
            if (handle == _handle) {
                const listener = this.messageAttachedMap.get(handle);
                listener && listener(data[0]);
            }
        };
        const attached_sub = ZIMEvent.addListener(Prefix + 'messageAttachedHook', native_messageAttached_listener);
        this.messageAttachedMap.set(_handle, messageAttachedCallBack);
        return ZIMNativeModule.editMessage(this.handle, message, _handle)
            .then((result) => {
            progress_sub && progress_sub.remove();
            attached_sub.remove();
            this.messageLoadingMap.delete(_handle);
            this.messageAttachedMap.delete(_handle);
            return result;
        })
            .catch((err) => {
            progress_sub && progress_sub.remove();
            attached_sub.remove();
            this.messageLoadingMap.delete(_handle);
            this.messageAttachedMap.delete(_handle);
            this.handleReject(err);
        });
    }
    deleteMessages(messageList, conversationID, conversationType, config) {
        config = Object.assign({ isAlsoDeleteServerMessage: true }, config);
        const error = this.paramValid.deleteMessages(messageList, conversationID, conversationType, config);
        if (error)
            return Promise.reject(error);
        if (!messageList.length && !config.isAlsoDeleteServerMessage)
            return Promise.resolve({ conversationID, conversationType });
        // Filter online message
        messageList = messageList.filter((msg) => msg.type != ZIMMessageType.Command && msg.type != ZIMMessageType.Barrage);
        messageList = JSON.parse(JSON.stringify(messageList));
        return ZIMNativeModule.deleteMessages(this.handle, messageList, conversationID, conversationType, config).catch(this.handleReject);
    }
    deleteAllMessage(conversationID, conversationType, config) {
        const error = this.paramValid.validConvIDAndType(conversationID, conversationType, ZIMLogAction.DeleteAllMessage);
        if (error)
            return Promise.reject(error);
        config = Object.assign({ isAlsoDeleteServerMessage: true }, config);
        return ZIMNativeModule.deleteAllMessage(this.handle, conversationID, conversationType, config).catch(this.handleReject);
    }
    queryHistoryMessage(conversationID, conversationType, config) {
        const error = this.paramValid.queryHistoryMessage(conversationID, conversationType, config);
        if (error)
            return Promise.reject(error);
        if (config.count < 1)
            return Promise.resolve({ conversationID, conversationType, messageList: [] });
        const nextMessage = config.nextMessage ? JSON.parse(JSON.stringify(config.nextMessage)) : void 0;
        if (nextMessage) {
            config = { ...config };
            config.nextMessage =
                nextMessage.type == ZIMMessageType.Command || nextMessage.type == ZIMMessageType.Barrage
                    ? void 0
                    : nextMessage;
        }
        return ZIMNativeModule.queryHistoryMessage(this.handle, conversationID, conversationType, config).catch(this.handleReject);
    }
    downloadMediaFile(_message, fileType, config, progress) {
        const error = this.paramValid.downloadMediaFile(_message, fileType);
        if (error)
            return Promise.reject(error);
        if (!config)
            config = { messageInfoIndex: 0 };
        if (!progress)
            progress = NOOP;
        const message = JSON.parse(JSON.stringify(_message));
        const _handle = createSymbol();
        const native_progress_listener = (res) => {
            const { handle, data } = res;
            if (handle == _handle) {
                const listener = this.messageLoadingMap.get(handle);
                // @ts-ignore
                listener && listener(...data);
            }
        };
        const progress_sub = ZIMEvent.addListener(Prefix + 'messageLoadingProgress', native_progress_listener);
        this.messageLoadingMap.set(_handle, progress);
        return ZIMNativeModule.downloadMediaFile(this.handle, message, fileType, config, _handle)
            .then((result) => {
            progress_sub.remove();
            this.messageLoadingMap.delete(_handle);
            return result;
        })
            .catch((err) => {
            progress_sub.remove();
            this.messageLoadingMap.delete(_handle);
            this.handleReject(err);
        });
    }
    importLocalMessages(folderPath, config, progress) {
        const error = this.paramValid.validID('folderPath', folderPath, ZIMLogTag.Conversation, ZIMLogAction.ImportLocalMessages);
        if (error)
            return Promise.reject(error);
        const _handle = createSymbol();
        const native_progress_listener = (res) => {
            const { handle, data } = res;
            if (handle == _handle) {
                const listener = this.messagePortMap.get(handle);
                // @ts-ignore
                listener && listener(...data);
            }
        };
        const progress_sub = ZIMEvent.addListener(Prefix + 'messagePortProgress', native_progress_listener);
        this.messagePortMap.set(_handle, progress);
        return ZIMNativeModule.importLocalMessages(this.handle, folderPath, _handle)
            .then(() => {
            progress_sub.remove();
            this.messagePortMap.delete(_handle);
        })
            .catch((err) => {
            progress_sub.remove();
            this.messagePortMap.delete(_handle);
            this.handleReject(err);
        });
    }
    exportLocalMessages(folderPath, config, progress) {
        const error = this.paramValid.validID('folderPath', folderPath, ZIMLogTag.Conversation, ZIMLogAction.ExportLocalMessages);
        if (error)
            return Promise.reject(error);
        const _handle = createSymbol();
        const native_progress_listener = (res) => {
            const { handle, data } = res;
            if (handle == _handle) {
                const listener = this.messagePortMap.get(handle);
                // @ts-ignore
                listener && listener(...data);
            }
        };
        const progress_sub = ZIMEvent.addListener(Prefix + 'messagePortProgress', native_progress_listener);
        this.messagePortMap.set(_handle, progress);
        return ZIMNativeModule.exportLocalMessages(this.handle, folderPath, _handle)
            .then(() => {
            progress_sub.remove();
            this.messagePortMap.delete(_handle);
        })
            .catch((err) => {
            progress_sub.remove();
            this.messagePortMap.delete(_handle);
            this.handleReject(err);
        });
    }
    insertMessageToLocalDB(_message, conversationID, conversationType, senderUserID) {
        const error = this.paramValid.insertMessageToLocalDB(_message, conversationID, conversationType, senderUserID);
        if (error)
            return Promise.reject(error);
        const message = JSON.parse(JSON.stringify(_message));
        return ZIMNativeModule.insertMessageToLocalDB(this.handle, message, conversationID, conversationType, senderUserID).catch(this.handleReject);
    }
    updateMessageLocalExtendedData(localExtendedData, _message) {
        const error = this.paramValid.updateMessageLocalExtendedData(localExtendedData, _message);
        if (error)
            return Promise.reject(error);
        const message = JSON.parse(JSON.stringify(_message));
        return ZIMNativeModule.updateMessageLocalExtendedData(this.handle, localExtendedData, message).catch(this.handleReject);
    }
    cancelSendingMessage(_message, config) {
        const error = this.paramValid.cancelSendingMessage(_message);
        if (error)
            return Promise.reject(error);
        const message = JSON.parse(JSON.stringify(_message));
        return ZIMNativeModule.cancelSendingMessage(this.handle, message, config).catch(this.handleReject);
    }
    revokeMessage(_message, config) {
        const error = this.paramValid.validSDKMessage(_message, ZIMLogAction.RevokeMessage);
        if (error)
            return Promise.reject(error);
        const message = JSON.parse(JSON.stringify(_message));
        return ZIMNativeModule.revokeMessage(this.handle, message, config).catch(this.handleReject);
    }
    queryCombineMessageDetail(_message) {
        const error = this.paramValid.queryCombineMessageDetail(_message);
        if (error)
            return Promise.reject(error);
        const message = JSON.parse(JSON.stringify(_message));
        return ZIMNativeModule.queryCombineMessageDetail(this.handle, message).catch(this.handleReject);
    }
    pinMessage(_message, isPinned) {
        const error = this.paramValid.validConvIDAndType(_message.conversationID, _message.conversationType, ZIMLogAction.PinMessage) || this.paramValid.validSDKMessage(_message, ZIMLogAction.PinMessage);
        if (error)
            return Promise.reject(error);
        const message = JSON.parse(JSON.stringify(_message));
        return ZIMNativeModule.pinMessage(this.handle, message, isPinned).catch(this.handleReject);
    }
    queryPinnedMessageList(conversationID, conversationType) {
        const error = this.paramValid.validConvIDAndType(conversationID, conversationType, ZIMLogAction.QueryPinnedMessageList);
        if (error)
            return Promise.reject(error);
        return ZIMNativeModule.queryPinnedMessageList(this.handle, conversationID, conversationType).catch(this.handleReject);
    }
    // MARK: - Message receipt
    sendConversationMessageReceiptRead(conversationID, conversationType) {
        const error = this.paramValid.sendReceiptRead(conversationID, conversationType);
        if (error)
            return Promise.reject(error);
        return ZIMNativeModule.sendConversationMessageReceiptRead(this.handle, conversationID, conversationType).catch(this.handleReject);
    }
    sendMessageReceiptsRead(messageList, conversationID, conversationType) {
        const error = this.paramValid.sendMessageReceiptsRead(messageList, conversationID, conversationType);
        if (error)
            return Promise.reject(error);
        // Filter online message
        messageList = messageList.filter((msg) => msg.type != ZIMMessageType.Command && msg.type != ZIMMessageType.Barrage);
        messageList = JSON.parse(JSON.stringify(messageList));
        return ZIMNativeModule.sendMessageReceiptsRead(this.handle, messageList, conversationID, conversationType).catch(this.handleReject);
    }
    queryMessageReceiptsInfo(messageList, conversationID, conversationType) {
        const error = this.paramValid.queryReceiptsInfo(messageList, conversationID, conversationType);
        if (error)
            return Promise.reject(error);
        // Filter online message
        messageList = messageList.filter((msg) => msg.type != ZIMMessageType.Command && msg.type != ZIMMessageType.Barrage);
        messageList = JSON.parse(JSON.stringify(messageList));
        return ZIMNativeModule.queryMessageReceiptsInfo(this.handle, messageList, conversationID, conversationType).catch(this.handleReject);
    }
    queryGroupMessageReceiptMemberList(_message, groupID, config, read) {
        const error = this.paramValid.queryReceiptMemberList(_message, groupID, config, read, this.loginUserID);
        if (error)
            return Promise.reject(error);
        if (config.count < 1 || config.nextFlag < 0 || _message.direction == ZIMMessageDirection.Receive) {
            return Promise.resolve({ groupID, nextFlag: 0, userList: [] });
        }
        config = Object.assign({ nextFlag: 0 }, config);
        const message = JSON.parse(JSON.stringify(_message));
        return ZIMNativeModule.queryGroupMessageReceiptMemberList(this.handle, message, groupID, config, read).catch(this.handleReject);
    }
    // MARK: - Message reaction
    addMessageReaction(reactionType, _message) {
        const error = this.paramValid.messageReaction(reactionType, _message, true);
        if (error)
            return Promise.reject(error);
        const message = JSON.parse(JSON.stringify(_message));
        return ZIMNativeModule.addMessageReaction(this.handle, reactionType, message).catch(this.handleReject);
    }
    deleteMessageReaction(reactionType, _message) {
        const error = this.paramValid.messageReaction(reactionType, _message);
        if (error)
            return Promise.reject(error);
        const message = JSON.parse(JSON.stringify(_message));
        return ZIMNativeModule.deleteMessageReaction(this.handle, reactionType, message).catch(this.handleReject);
    }
    queryMessageReactionUserList(_message, config) {
        const error = this.paramValid.queryMessageBase(_message, config, ZIMLogAction.QueryReaction);
        if (error)
            return Promise.reject(error);
        if (config.count < 1 || config.nextFlag < 0) {
            const res = {
                totalCount: 0,
                nextFlag: 0,
                reactionType: config.reactionType,
                userList: [],
                message: _message,
            };
            return Promise.resolve(res);
        }
        config = Object.assign({ nextFlag: 0 }, config);
        const message = JSON.parse(JSON.stringify(_message));
        return ZIMNativeModule.queryMessageReactionUserList(this.handle, message, config).catch(this.handleReject);
    }
    queryMessageRepliedList(_message, config) {
        const error = this.paramValid.queryMessageBase(_message, config, ZIMLogAction.QueryReplyMsg);
        if (error)
            return Promise.reject(error);
        const message = JSON.parse(JSON.stringify(_message));
        return ZIMNativeModule.queryMessageRepliedList(this.handle, message, config).catch(this.handleReject);
    }
    queryMessages(messageSeqs, conversationID, conversationType) {
        const error = this.paramValid.validConvIDAndType(conversationID, conversationType, ZIMLogAction.QueryMsgs);
        if (error)
            return Promise.reject(error);
        return ZIMNativeModule.queryMessages(this.handle, messageSeqs, conversationID, conversationType).catch(this.handleReject);
    }
    // MARK: - Room
    createRoom(roomInfo, config) {
        const error = this.paramValid.createRoom(ZIMLogAction.CreateRoom, roomInfo, config);
        if (error)
            return Promise.reject(error);
        return ZIMNativeModule.createRoom(this.handle, roomInfo, config).catch(this.handleReject);
    }
    enterRoom(roomInfo, config) {
        const error = this.paramValid.createRoom(ZIMLogAction.EnterRoom, roomInfo, config);
        if (error)
            return Promise.reject(error);
        return ZIMNativeModule.enterRoom(this.handle, roomInfo, config).catch(this.handleReject);
    }
    joinRoom(roomID) {
        const error = this.paramValid.validID('roomID', roomID, ZIMLogTag.Room, ZIMLogAction.JoinRoom);
        if (error)
            return Promise.reject(error);
        return ZIMNativeModule.joinRoom(this.handle, roomID).catch(this.handleReject);
    }
    switchRoom(fromRoomID, toRoomInfo, isCreateWhenRoomNotExisted, config) {
        let error = this.paramValid.validID('fromRoomID', fromRoomID, ZIMLogTag.Room, ZIMLogAction.SwitchRoom) ||
            this.paramValid.createRoom(ZIMLogAction.SwitchRoom, toRoomInfo, config);
        if (error)
            return Promise.reject(error);
        return ZIMNativeModule.switchRoom(this.handle, fromRoomID, toRoomInfo, isCreateWhenRoomNotExisted, config).catch(this.handleReject);
    }
    leaveRoom(roomID) {
        const error = this.paramValid.validID('roomID', roomID, ZIMLogTag.Room, ZIMLogAction.LeaveRoom);
        if (error)
            return Promise.reject(error);
        return ZIMNativeModule.leaveRoom(this.handle, roomID).catch(this.handleReject);
    }
    leaveAllRoom() {
        return ZIMNativeModule.leaveAllRoom(this.handle).catch(this.handleReject);
    }
    queryRoomMemberList(roomID, config) {
        const error = this.paramValid.validCount(config, ZIMLogTag.Room, ZIMLogAction.QueryRoomMemberList, 'roomID', roomID);
        if (error)
            return Promise.reject(error);
        if (config.count < 1)
            return Promise.resolve({ roomID, memberList: [], nextFlag: '' });
        return ZIMNativeModule.queryRoomMemberList(this.handle, roomID, config).catch(this.handleReject);
    }
    queryRoomMembers(userIDs, roomID) {
        const error = this.paramValid.validIDAndArray('roomID', roomID, 'userIDs', userIDs, ZIMLogTag.Room, ZIMLogAction.QueryRoomMemberList);
        if (error)
            return Promise.reject(error);
        return ZIMNativeModule.queryRoomMembers(this.handle, userIDs, roomID).catch(this.handleReject);
    }
    queryRoomOnlineMemberCount(roomID) {
        const error = this.paramValid.validID('roomID', roomID, ZIMLogTag.Room, ZIMLogAction.QueryRoomOnlineMemberCount);
        if (error)
            return Promise.reject(error);
        return ZIMNativeModule.queryRoomOnlineMemberCount(this.handle, roomID).catch(this.handleReject);
    }
    queryRoomAllAttributes(roomID) {
        const error = this.paramValid.validID('roomID', roomID, ZIMLogTag.Room, ZIMLogAction.QueryRoomAllAttributes);
        if (error)
            return Promise.reject(error);
        return ZIMNativeModule.queryRoomAllAttributes(this.handle, roomID).catch(this.handleReject);
    }
    setRoomAttributes(roomAttributes, roomID, config) {
        const error = this.paramValid.setRoomAttributes(roomAttributes, roomID);
        if (error)
            return Promise.reject(error);
        return ZIMNativeModule.setRoomAttributes(this.handle, roomAttributes, roomID, config).catch(this.handleReject);
    }
    deleteRoomAttributes(keys, roomID, config) {
        const error = this.paramValid.validIDAndArray('roomID', roomID, 'keys', keys, ZIMLogTag.Room, ZIMLogAction.DeleteRoomAttributes);
        if (error)
            return Promise.reject(error);
        return ZIMNativeModule.deleteRoomAttributes(this.handle, keys, roomID, config).catch(this.handleReject);
    }
    beginRoomAttributesBatchOperation(roomID, config) {
        ZIMNativeModule.beginRoomAttributesBatchOperation(this.handle, roomID, config);
    }
    endRoomAttributesBatchOperation(roomID) {
        const error = this.paramValid.validID('roomID', roomID, ZIMLogTag.Room, ZIMLogAction.EndRoomAttributesBatchOperation);
        if (error)
            return Promise.reject(error);
        return ZIMNativeModule.endRoomAttributesBatchOperation(this.handle, roomID).catch(this.handleReject);
    }
    setRoomMembersAttributes(attributes, userIDs, roomID, config) {
        const error = this.paramValid.setRoomMembersAttributes(attributes, userIDs, roomID);
        if (error)
            return Promise.reject(error);
        return ZIMNativeModule.setRoomMembersAttributes(this.handle, attributes, userIDs, roomID, config).catch(this.handleReject);
    }
    queryRoomMembersAttributes(userIDs, roomID) {
        const error = this.paramValid.validIDAndArray('roomID', roomID, 'userIDs', userIDs, ZIMLogTag.Room, ZIMLogAction.QueryRoomMembersAttributes);
        if (error)
            return Promise.reject(error);
        return ZIMNativeModule.queryRoomMembersAttributes(this.handle, userIDs, roomID).catch(this.handleReject);
    }
    queryRoomMemberAttributesList(roomID, config) {
        const error = this.paramValid.validID('roomID', roomID, ZIMLogTag.Room, ZIMLogAction.QueryRoomMemberAttributesList);
        if (error)
            return Promise.reject(error);
        if (config && config.count < 1)
            return Promise.resolve({ roomID, nextFlag: '', infos: [] });
        return ZIMNativeModule.queryRoomMemberAttributesList(this.handle, roomID, config).catch(this.handleReject);
    }
    // MARK: - Group
    createGroup(groupInfo, userIDs, config) {
        groupInfo = Object.assign({ groupID: '', groupName: '', groupAvatarUrl: '' }, groupInfo);
        config = Object.assign({ groupAttributes: {}, groupNotice: '' }, config);
        const error = this.paramValid.createGroup(groupInfo, userIDs, config);
        if (error)
            return Promise.reject(error);
        return ZIMNativeModule.createGroup(this.handle, groupInfo, userIDs, config).catch(this.handleReject);
    }
    joinGroup(isJoin, groupID, config) {
        const action = isJoin ? ZIMLogAction.JoinGroup : ZIMLogAction.SendGroupJoinApp;
        const error = this.paramValid.validID('groupID', groupID, ZIMLogTag.Group, action);
        if (error)
            return Promise.reject(error);
        return isJoin
            ? ZIMNativeModule.joinGroup(this.handle, groupID).catch(this.handleReject)
            : ZIMNativeModule.sendGroupJoinApplication(this.handle, groupID, config || {}).catch(this.handleReject);
    }
    leaveGroup(groupID) {
        const error = this.paramValid.validID('groupID', groupID, ZIMLogTag.Group, ZIMLogAction.LeaveGroup);
        if (error)
            return Promise.reject(error);
        return ZIMNativeModule.leaveGroup(this.handle, groupID).catch(this.handleReject);
    }
    dismissGroup(groupID) {
        const error = this.paramValid.validID('groupID', groupID, ZIMLogTag.Group, ZIMLogAction.DismissGroup);
        if (error)
            return Promise.reject(error);
        return ZIMNativeModule.dismissGroup(this.handle, groupID).catch(this.handleReject);
    }
    queryGroupList(count, config) {
        return ZIMNativeModule.queryGroupList(this.handle, count, config).catch(this.handleReject);
    }
    updateGroupName(groupName, groupID) {
        const error = this.paramValid.validIDAndName('groupID', groupID, 'groupName', groupName, ZIMLogTag.Group, ZIMLogAction.UpdateGroupInfo);
        if (error)
            return Promise.reject(error);
        return ZIMNativeModule.updateGroupName(this.handle, groupName, groupID).catch(this.handleReject);
    }
    updateGroupNotice(groupNotice, groupID) {
        const error = this.paramValid.validIDAndName('groupID', groupID, 'groupNotice', groupNotice, ZIMLogTag.Group, ZIMLogAction.UpdateGroupInfo);
        if (error)
            return Promise.reject(error);
        return ZIMNativeModule.updateGroupNotice(this.handle, groupNotice, groupID).catch(this.handleReject);
    }
    updateGroupAvatarUrl(groupAvatarUrl, groupID) {
        const error = this.paramValid.validIDAndName('groupID', groupID, 'groupAvatarUrl', groupAvatarUrl, ZIMLogTag.Group, ZIMLogAction.UpdateGroupInfo);
        if (error)
            return Promise.reject(error);
        return ZIMNativeModule.updateGroupAvatarUrl(this.handle, groupAvatarUrl, groupID).catch(this.handleReject);
    }
    muteGroup(isMute, groupID, config) {
        config = Object.assign({ mode: ZIMGroupMuteMode.All, duration: -1, roles: [] }, config);
        if (!isMute) {
            config.mode = ZIMGroupMuteMode.None;
            config.duration = 0;
            config.roles = [];
        }
        const error = this.paramValid.muteGroup(groupID, config, isMute);
        if (error)
            return Promise.reject(error);
        return ZIMNativeModule.muteGroup(this.handle, !!isMute, groupID, config).catch(this.handleReject);
    }
    queryGroupInfo(groupID) {
        const error = this.paramValid.validID('groupID', groupID, ZIMLogTag.Group, ZIMLogAction.QueryGroupInfo);
        if (error)
            return Promise.reject(error);
        return ZIMNativeModule.queryGroupInfo(this.handle, groupID).catch(this.handleReject);
    }
    setGroupAttributes(groupAttributes, groupID) {
        const error = this.paramValid.setGroupAttributes(groupAttributes, groupID);
        if (error)
            return Promise.reject(error);
        return ZIMNativeModule.setGroupAttributes(this.handle, groupAttributes, groupID).catch(this.handleReject);
    }
    deleteGroupAttributes(keys, groupID) {
        const error = this.paramValid.validIDAndArray('groupID', groupID, 'keys', keys, ZIMLogTag.Group, ZIMLogAction.DeleteGroupAttributes);
        if (error)
            return Promise.reject(error);
        return ZIMNativeModule.deleteGroupAttributes(this.handle, keys, groupID).catch(this.handleReject);
    }
    queryGroupAttributes(keys, groupID) {
        const error = this.paramValid.queryGroupAttributes(groupID, keys);
        if (error)
            return Promise.reject(error);
        return ZIMNativeModule.queryGroupAttributes(this.handle, keys, groupID).catch(this.handleReject);
    }
    queryGroupAllAttributes(groupID) {
        const error = this.paramValid.queryGroupAttributes(groupID);
        if (error)
            return Promise.reject(error);
        return ZIMNativeModule.queryGroupAllAttributes(this.handle, groupID).catch(this.handleReject);
    }
    updateGroupAlias(groupAlias, groupID) {
        const error = this.paramValid.validIDAndName('groupID', groupID, 'groupAlias', groupAlias, ZIMLogTag.Group, ZIMLogAction.UpdateGroupAlias);
        if (error)
            return Promise.reject(error);
        return ZIMNativeModule.updateGroupAlias(this.handle, groupAlias, groupID).catch(this.handleReject);
    }
    setGroupMemberNickname(nickname, forUserID, groupID) {
        const error = this.paramValid.setGroupMemberNickname(nickname, forUserID, groupID);
        if (error)
            return Promise.reject(error);
        return ZIMNativeModule.setGroupMemberNickname(this.handle, nickname, forUserID, groupID).catch(this.handleReject);
    }
    setGroupMemberRole(role, forUserID, groupID) {
        const error = this.paramValid.setGroupMemberRole(role, forUserID, groupID);
        if (error)
            return Promise.reject(error);
        return ZIMNativeModule.setGroupMemberRole(this.handle, role, forUserID, groupID).catch(this.handleReject);
    }
    transferGroupOwner(toUserID, groupID) {
        const error = this.paramValid.validTwoID('toUserID', toUserID, 'groupID', groupID, ZIMLogTag.Group, ZIMLogAction.TransferGroupOwner);
        if (error)
            return Promise.reject(error);
        return ZIMNativeModule.transferGroupOwner(this.handle, toUserID, groupID).catch(this.handleReject);
    }
    queryGroupMemberInfo(userID, groupID) {
        const error = this.paramValid.validTwoID('userID', userID, 'groupID', groupID, ZIMLogTag.Group, ZIMLogAction.QueryGroupMemberInfo);
        if (error)
            return Promise.reject(error);
        return ZIMNativeModule.queryGroupMemberInfo(this.handle, userID, groupID).catch(this.handleReject);
    }
    inviteUsersIntoGroup(isApply, userIDs, groupID, config) {
        const error = this.paramValid.validIDAndArray('groupID', groupID, 'userIDs', userIDs, ZIMLogTag.Group, isApply ? ZIMLogAction.SendGroupInviteApp : ZIMLogAction.InviteUsersIntoGroup);
        if (error)
            return Promise.reject(error);
        return isApply
            ? ZIMNativeModule.sendGroupInviteApplications(this.handle, userIDs, groupID, config || {}).catch(this.handleReject)
            : ZIMNativeModule.inviteUsersIntoGroup(this.handle, userIDs, groupID).catch(this.handleReject);
    }
    kickGroupMembers(userIDs, groupID) {
        const error = this.paramValid.validIDAndArray('groupID', groupID, 'userIDs', userIDs, ZIMLogTag.Group, ZIMLogAction.KickGroupMembers);
        if (error)
            return Promise.reject(error);
        return ZIMNativeModule.kickGroupMembers(this.handle, userIDs, groupID).catch(this.handleReject);
    }
    queryGroupMemberList(groupID, config) {
        config = Object.assign({ count: 100, nextFlag: 0 }, config);
        const error = this.paramValid.validCount(config, ZIMLogTag.Group, ZIMLogAction.QueryGroupMemberList, 'groupID', groupID);
        if (error)
            return Promise.reject(error);
        if (config.count < 1 || config.nextFlag < 0)
            return Promise.resolve({ groupID, userList: [], nextFlag: 0 });
        return ZIMNativeModule.queryGroupMemberList(this.handle, groupID, config).catch(this.handleReject);
    }
    queryGroupMemberCount(groupID) {
        const error = this.paramValid.validID('groupID', groupID, ZIMLogTag.Group, ZIMLogAction.QueryGroupMemberCount);
        if (error)
            return Promise.reject(error);
        return ZIMNativeModule.queryGroupMemberCount(this.handle, groupID).catch(this.handleReject);
    }
    muteGroupMembers(isMute, userIDs, groupID, config) {
        const error = this.paramValid.validIDAndArray('groupID', groupID, 'userIDs', userIDs, ZIMLogTag.Group, ZIMLogAction.MuteGroupMembers);
        if (error)
            return Promise.reject(error);
        config = Object.assign({ duration: 0 }, config);
        return ZIMNativeModule.muteGroupMembers(this.handle, !!isMute, userIDs, groupID, config).catch(this.handleReject);
    }
    queryGroupMemberMutedList(groupID, config) {
        config = Object.assign({ count: 100, nextFlag: 0 }, config);
        const error = this.paramValid.validCount(config, ZIMLogTag.Group, ZIMLogAction.QueryGroupMemberMutedList, 'groupID', groupID);
        if (error)
            return Promise.reject(error);
        if (config.count < 1)
            return Promise.resolve({ groupID, userList: [], nextFlag: config.nextFlag });
        return ZIMNativeModule.queryGroupMemberMutedList(this.handle, groupID, config).catch(this.handleReject);
    }
    updateGroupVerifyMode(mode, groupID, type) {
        const error = this.paramValid.updateGroupVerifyMode(mode, groupID, type);
        if (error)
            return Promise.reject(error);
        if (type == 0) {
            return ZIMNativeModule.updateGroupJoinMode(this.handle, mode, groupID).catch(this.handleReject);
        }
        else if (type == 1) {
            return ZIMNativeModule.updateGroupInviteMode(this.handle, mode, groupID).catch(this.handleReject);
        }
        else {
            return ZIMNativeModule.updateGroupBeInviteMode(this.handle, mode, groupID).catch(this.handleReject);
        }
    }
    acceptGroupApply(isJoin, userID, groupID, config) {
        const error = this.paramValid.validTwoID('userID', userID, 'groupID', groupID, ZIMLogTag.Group, 'API.acceptGroupApplication');
        if (error)
            return Promise.reject(error);
        config = config || {};
        return isJoin
            ? ZIMNativeModule.acceptGroupJoinApplication(this.handle, userID, groupID, config).catch(this.handleReject)
            : ZIMNativeModule.acceptGroupInviteApplication(this.handle, userID, groupID, config).catch(this.handleReject);
    }
    rejectGroupApply(isJoin, userID, groupID, config) {
        const error = this.paramValid.validTwoID('userID', userID, 'groupID', groupID, ZIMLogTag.Group, 'API.rejectGroupApplication');
        if (error)
            return Promise.reject(error);
        config = config || {};
        return isJoin
            ? ZIMNativeModule.rejectGroupJoinApplication(this.handle, userID, groupID, config).catch(this.handleReject)
            : ZIMNativeModule.rejectGroupInviteApplication(this.handle, userID, groupID, config).catch(this.handleReject);
    }
    queryGroupApplyList(config) {
        config = Object.assign({ count: 100, nextFlag: 0 }, config);
        const error = this.paramValid.validCount(config, ZIMLogTag.Group, ZIMLogAction.QueryGroupApp);
        if (error)
            return Promise.reject(error);
        if (config.count < 1)
            return Promise.resolve({ applicationList: [], nextFlag: config.nextFlag });
        return ZIMNativeModule.queryGroupApplicationList(this.handle, config).catch(this.handleReject);
    }
    // MARK: - Call
    callInvite(invitees, config) {
        const error = this.paramValid.callInvite(invitees, config);
        if (error)
            return Promise.reject(error);
        config = Object.assign({ mode: 0, timeout: 90 }, config);
        if (config.pushConfig) {
            config.pushConfig.payload = config.pushConfig.payload || '';
            config.pushConfig.resourcesID = config.pushConfig.resourcesID || '';
        }
        return ZIMNativeModule.callInvite(this.handle, invitees, config).catch(this.handleReject);
    }
    callCancel(invitees, callID, config) {
        const error = this.paramValid.validCallID(callID, ZIMLogAction.CallCancel);
        if (error)
            return Promise.reject(error);
        return ZIMNativeModule.callCancel(this.handle, invitees, callID, config).catch(this.handleReject);
    }
    callAccept(callID, config) {
        const error = this.paramValid.validCallID(callID, ZIMLogAction.CallAccept);
        if (error)
            return Promise.reject(error);
        return ZIMNativeModule.callAccept(this.handle, callID, config).catch(this.handleReject);
    }
    callReject(callID, config) {
        const error = this.paramValid.validCallID(callID, ZIMLogAction.CallReject);
        if (error)
            return Promise.reject(error);
        return ZIMNativeModule.callReject(this.handle, callID, config).catch(this.handleReject);
    }
    callQuit(callID, config) {
        const error = this.paramValid.validCallID(callID, ZIMLogAction.CallQuit);
        if (error)
            return Promise.reject(error);
        return ZIMNativeModule.callQuit(this.handle, callID, config).catch(this.handleReject);
    }
    callEnd(callID, config) {
        const error = this.paramValid.validCallID(callID, ZIMLogAction.CallEnd);
        if (error)
            return Promise.reject(error);
        return ZIMNativeModule.callEnd(this.handle, callID, config).catch(this.handleReject);
    }
    callJoin(callID, config) {
        const error = this.paramValid.validCallID(callID, ZIMLogAction.CallJoin);
        if (error)
            return Promise.reject(error);
        return ZIMNativeModule.callJoin(this.handle, callID, config).catch(this.handleReject);
    }
    callingInvite(invitees, callID, config) {
        const error = this.paramValid.validIDAndArray('callID', callID, 'invitees', invitees, ZIMLogTag.Call, ZIMLogAction.CallingInvite);
        if (error)
            return Promise.reject(error);
        return ZIMNativeModule.callingInvite(this.handle, invitees, callID, config).catch(this.handleReject);
    }
    queryCallInvitationList(config) {
        if (!config.count || config.count < 1)
            return Promise.resolve({ callList: [], nextFlag: 0 });
        config = Object.assign({ nextFlag: 0 }, config);
        return ZIMNativeModule.queryCallInvitationList(this.handle, config).catch(this.handleReject);
    }
    // MARK: - DB Search
    searchConversations(config) {
        const error = this.paramValid.searchConversations(config);
        if (error)
            return Promise.reject(error);
        config = Object.assign({ nextFlag: 0, startTime: 0, endTime: 0 }, config);
        return ZIMNativeModule.searchConversations(this.handle, config).catch(this.handleReject);
    }
    searchGlobalMessages(config) {
        const error = this.paramValid.searchMessages(config, ZIMLogAction.SearchGlobalMessages);
        if (error)
            return Promise.reject(error);
        config = Object.assign({ order: 0, startTime: 0, endTime: 0 }, config);
        const nextMessage = config.nextMessage ? JSON.parse(JSON.stringify(config.nextMessage)) : void 0;
        if (nextMessage) {
            config.nextMessage =
                nextMessage.type == ZIMMessageType.Command || nextMessage.type == ZIMMessageType.Barrage
                    ? void 0
                    : nextMessage;
        }
        return ZIMNativeModule.searchGlobalMessages(this.handle, config).catch(this.handleReject);
    }
    searchMessages(conversationID, conversationType, config) {
        const error = this.paramValid.validConvIDAndType(conversationID, conversationType, ZIMLogAction.SearchMessages) ||
            this.paramValid.searchMessages(config, ZIMLogAction.SearchMessages);
        if (error)
            return Promise.reject(error);
        config = Object.assign({ order: 0, startTime: 0, endTime: 0 }, config);
        const nextMessage = config.nextMessage ? JSON.parse(JSON.stringify(config.nextMessage)) : void 0;
        if (nextMessage) {
            config.nextMessage =
                nextMessage.type == ZIMMessageType.Command || nextMessage.type == ZIMMessageType.Barrage
                    ? void 0
                    : nextMessage;
        }
        return ZIMNativeModule.searchMessages(this.handle, conversationID, conversationType, config).catch(this.handleReject);
    }
    searchGroups(config) {
        const error = this.paramValid.searchBase(config, ZIMLogAction.SearchGroups);
        if (error)
            return Promise.reject(error);
        config = Object.assign({ nextFlag: 0 }, config);
        return ZIMNativeModule.searchGroups(this.handle, config).catch(this.handleReject);
    }
    searchGroupMembers(groupID, config) {
        const error = this.paramValid.validID('groupID', groupID, ZIMLogTag.Database, ZIMLogAction.SearchGroupMembers) ||
            this.paramValid.searchBase(config, ZIMLogAction.SearchGroupMembers);
        if (error)
            return Promise.reject(error);
        config = Object.assign({ nextFlag: 0 }, config);
        return ZIMNativeModule.searchGroupMembers(this.handle, groupID, config).catch(this.handleReject);
    }
    searchFriends(config) {
        const error = this.paramValid.searchBase(config, ZIMLogAction.SearchFriends);
        if (error)
            return Promise.reject(error);
        config = Object.assign({ nextFlag: 0 }, config);
        return ZIMNativeModule.searchFriends(this.handle, config).catch(this.handleReject);
    }
    // MARK: - Friend
    addFriend(userID, config) {
        const error = this.paramValid.addFriend(userID, config);
        if (error)
            return Promise.reject(error);
        config.friendAttributes = config.friendAttributes || {};
        return ZIMNativeModule.addFriend(this.handle, userID, config).catch(this.handleReject);
    }
    sendFriendApplication(userID, config) {
        const error = this.paramValid.addFriend(userID, config);
        if (error)
            return Promise.reject(error);
        config.friendAttributes = config.friendAttributes || {};
        return ZIMNativeModule.sendFriendApplication(this.handle, userID, config).catch(this.handleReject);
    }
    deleteFriends(userIDs, config) {
        const error = this.paramValid.validArray('userIDs', userIDs, ZIMLogTag.Friend, ZIMLogAction.DeleteFriends);
        if (error)
            return Promise.reject(error);
        return ZIMNativeModule.deleteFriends(this.handle, userIDs, config).catch(this.handleReject);
    }
    checkFriendsRelation(userIDs, config) {
        const error = this.paramValid.validArray('userIDs', userIDs, ZIMLogTag.Friend, ZIMLogAction.DeleteFriends);
        if (error)
            return Promise.reject(error);
        return ZIMNativeModule.checkFriendsRelation(this.handle, userIDs, config).catch(this.handleReject);
    }
    updateFriendAlias(friendAlias, userID) {
        const error = this.paramValid.updateFriendAlias(friendAlias, userID);
        if (error)
            return Promise.reject(error);
        return ZIMNativeModule.updateFriendAlias(this.handle, friendAlias, userID).catch(this.handleReject);
    }
    updateFriendAttributes(friendAttributes, userID) {
        const error = this.paramValid.updateFriendAttributes(friendAttributes, userID);
        if (error)
            return Promise.reject(error);
        return ZIMNativeModule.updateFriendAttributes(this.handle, friendAttributes, userID).catch(this.handleReject);
    }
    acceptFriendApplication(userID, config) {
        const error = this.paramValid.acceptFriendApplication(userID, config);
        if (error)
            return Promise.reject(error);
        config = config || {};
        config.friendAttributes = config.friendAttributes || {};
        return ZIMNativeModule.acceptFriendApplication(this.handle, userID, config).catch(this.handleReject);
    }
    rejectFriendApplication(userID, config) {
        return ZIMNativeModule.rejectFriendApplication(this.handle, userID, config).catch(this.handleReject);
    }
    queryFriendsInfo(userIDs) {
        const error = this.paramValid.validArray('userIDs', userIDs, ZIMLogTag.Friend, ZIMLogAction.QueryFriendsInfo, 20);
        if (error)
            return Promise.reject(error);
        return ZIMNativeModule.queryFriendsInfo(this.handle, userIDs).catch(this.handleReject);
    }
    queryFriendList(config) {
        const error = this.paramValid.validCount(config, ZIMLogTag.Friend, ZIMLogAction.QueryFriendList);
        if (error)
            return Promise.reject(error);
        config = Object.assign({ nextFlag: 0 }, config);
        return ZIMNativeModule.queryFriendList(this.handle, config).catch(this.handleReject);
    }
    queryFriendApplicationList(config) {
        const error = this.paramValid.validCount(config, ZIMLogTag.Friend, ZIMLogAction.QueryFriendAppList);
        if (error)
            return Promise.reject(error);
        config = Object.assign({ nextFlag: 0 }, config);
        return ZIMNativeModule.queryFriendApplicationList(this.handle, config).catch(this.handleReject);
    }
    // MARK: - Blacklis
    addUsersToBlacklist(userIDs) {
        const error = this.paramValid.validArray('userIDs', userIDs, ZIMLogTag.Friend, ZIMLogAction.AddUserToBlacklist);
        if (error)
            return Promise.reject(error);
        return ZIMNativeModule.addUsersToBlacklist(this.handle, userIDs).catch(this.handleReject);
    }
    removeUsersFromBlacklist(userIDs) {
        const error = this.paramValid.validArray('userIDs', userIDs, ZIMLogTag.Friend, ZIMLogAction.RemoveUsersFromBlacklist);
        if (error)
            return Promise.reject(error);
        return ZIMNativeModule.removeUsersFromBlacklist(this.handle, userIDs).catch(this.handleReject);
    }
    checkUserIsInBlacklist(userID) {
        const error = this.paramValid.validID('userID', userID, ZIMLogTag.Friend, ZIMLogAction.CheckUserIsInBlacklist);
        if (error)
            return Promise.reject(error);
        return ZIMNativeModule.checkUserIsInBlacklist(this.handle, userID).catch(this.handleReject);
    }
    queryBlacklist(config) {
        const error = this.paramValid.validCount(config, ZIMLogTag.Friend, ZIMLogAction.QueryBlacklist);
        if (error)
            return Promise.reject(error);
        config = Object.assign({ nextFlag: 0 }, config);
        return ZIMNativeModule.queryBlacklist(this.handle, config).catch(this.handleReject);
    }
}
