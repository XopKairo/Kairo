"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _reactNative = require("react-native");
var _zegoUikitRn = _interopRequireDefault(require("@zegocloud/zego-uikit-rn"));
var _logger = require("../../utils/logger");
var _report = _interopRequireDefault(require("../../utils/report"));
var _call_invite_helper = _interopRequireDefault(require("./call_invite_helper"));
var _inner_text_helper = _interopRequireDefault(require("./inner_text_helper"));
var _plugins = _interopRequireDefault(require("./plugins"));
var _NotificationHelper;
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
const {
  ZegoUIKitPrebuiltCallRNModule
} = _reactNative.NativeModules;
const eventEmitter = new _reactNative.NativeEventEmitter(ZegoUIKitPrebuiltCallRNModule);
class NotificationHelper {
  constructor() {
    _defineProperty(this, "TAG", 'NotificationHelper');
    _defineProperty(this, "_signalingPlugin", _zegoUikitRn.default.getSignalingPlugin());
    _defineProperty(this, "_uikitSignalingPlugin", _zegoUikitRn.default.getSignalingPlugin().getZegoUIKitSignalingPlugin().getInstance());
    _defineProperty(this, "_callbackID", `${this.TAG}_${String(Math.floor(Math.random() * 10000))}`);
    _defineProperty(this, "_callData", {});
    _defineProperty(this, "_callIDUuidMap", new Map());
    _defineProperty(this, "_currentCallID", '');
    _defineProperty(this, "_currentCallStatus", 'waiting');
    _defineProperty(this, "_alreadyInit", false);
    _defineProperty(this, "_plugins", []);
    _reactNative.AppState.addEventListener('change', async nextState => {
      (0, _logger.zloginfo)('nextState', nextState);
      if (nextState === 'active') {
        this.dismissNotification(this._currentCallID, 'active', this.TAG);
      }
    });
  }
  static getInstance() {
    return this._instance || (this._instance = new NotificationHelper());
  }
  init(plugins) {
    if (this._alreadyInit) {
      return;
    }
    (0, _logger.zloginfo)(`[NotificationHelper][init]`);
    this._plugins = plugins;
    eventEmitter.addListener('RNCallKitPerformEndCallAction', data => {
      (0, _logger.zloginfo)(`[EventListener] receive RNCallKitPerformEndCallAction from NativeModule, action: ${data}`);
      this._onCallKitEndCall(data);
    });
    (0, _logger.zloginfo)(`[NotificationHelper][init] set onCallKitEndCall`);
    eventEmitter.addListener('RNCallKitPerformAnswerCallAction', data => {
      (0, _logger.zloginfo)(`[EventListener] receive RNCallKitPerformAnswerCallAction from NativeModule, action: ${data}`);
      this._onCallKitAnswerCall();
    });
    (0, _logger.zloginfo)(`[NotificationHelper][init] set onCallKitAnswerCall`);
    this._alreadyInit = true;
  }

  // for offline call
  showOfflineNotification(callID, callUUID, callData) {
    if (!callData) {
      (0, _logger.zlogerror)('[NotificationHelper][showOfflineNotification] callData is empty');
      return;
    }
    (0, _logger.zloginfo)(`[NotificationHelper][showOfflineNotification] callID: ${callID}, callUUID: ${callUUID}, callData: ${JSON.stringify(callData)}`);
    let notifyUuid = this._callIDUuidMap.get(callID);
    if (notifyUuid) {
      (0, _logger.zloginfo)(`[NotificationHelper][showOfflineNotification] callID: ${callID} ignore, already shown notification`);
      return;
    }
    this._callIDUuidMap.set(callID, callUUID);
    let {
      call_id: roomID,
      call_name,
      type,
      inviter,
      invitees,
      timeout
    } = callData;
    if (this._currentCallID && this._currentCallStatus === 'notification') {
      (0, _logger.zloginfo)(`[NotificationHelper][showOfflineNotification] another call is showing`);
      this._offlineRefuse(callID, roomID, inviter, 'busy');
      return;
    }
    this._currentCallID = callID;
    this._currentCallStatus = 'notification';
    (0, _logger.zloginfo)(`[NotificationHelper][showOfflineNotification] set _currentCallID: ${this._currentCallID}, status: ${this._currentCallStatus}`);
    _call_invite_helper.default.getInstance().setOfflineData(undefined);

    // callID mean zim callID
    this._callData = {
      callID,
      roomID,
      call_name,
      type,
      inviter,
      invitees,
      isPureOfflinePush: true
    };
    (0, _logger.zloginfo)(`[NotificationHelper][showOfflineNotification] _callData: ${JSON.stringify(this._callData)}`);
    const callerName = call_name ?? _inner_text_helper.default.instance().getIncomingCallDialogTitle(inviter.name, type, invitees.length);
    const message = _inner_text_helper.default.instance().getIncomingCallDialogMessage(type, invitees.length);
    (0, _logger.zloginfo)(`[NotificationHelper][showOfflineNotification], callerName: ${callerName}, message: ${message}`);
    this._displayIncomingCall(callID, callerName, message, timeout ?? 60, 'restarted');
  }

  // for online call when background
  showOnlineNotification(callID, callData) {
    let notifyTag = this._callIDUuidMap.get(callID);
    if (notifyTag) {
      (0, _logger.zloginfo)(`[NotificationHelper][showOnlineNotification] callID: ${callID} ignore, already shown notification`);
      return;
    }
    if (!callData) {
      (0, _logger.zlogerror)('[NotificationHelper][showOnlineNotification] _callData is empty');
      return;
    }

    // @ts-ignore
    let {
      roomID,
      type,
      inviter,
      invitees,
      timeout
    } = callData;
    (0, _logger.zloginfo)(`[NotificationHelper][showOnlineNotification] callID: ${callID}, roomID: ${roomID}, isVideoCall: ${type}, inviter: ${JSON.stringify(inviter)}, invitees: ${JSON.stringify(invitees)}, timeout: ${timeout}`);
    const callerName = _inner_text_helper.default.instance().getIncomingCallDialogTitle(inviter.name, type, invitees.length);
    const message = _inner_text_helper.default.instance().getIncomingCallDialogMessage(type, invitees.length);
    (0, _logger.zloginfo)(`[NotificationHelper][showOnlineNotification], callerName: ${callerName}, message: ${message}`);
    this._displayIncomingCall(callID, callerName, message, timeout ?? 60, _reactNative.AppState.currentState);
    this._currentCallID = callID;
    this._currentCallStatus = 'notification';
    (0, _logger.zloginfo)(`[NotificationHelper][showOnlineNotification] set _currentCallID: ${this._currentCallID}, status: ${this._currentCallStatus}`);
    notifyTag = Date.now().toString();
    this._callIDUuidMap.set(callID, notifyTag);
    (0, _logger.zloginfo)(`[NotificationHelper][showOnlineNotification] set ${callID} into _callIDUuidMap`);

    // callID mean zim callID
    this._callData = {
      callID,
      roomID,
      type,
      inviter,
      invitees
    };
    (0, _logger.zloginfo)(`[NotificationHelper][showOnlineNotification] _callData: ${JSON.stringify(this._callData)}`);
  }
  _displayIncomingCall(callID, callerName, message, timeout, appState) {
    var areEnabledPromise = _reactNative.Platform.Version < 33 ? ZegoUIKitPrebuiltCallRNModule.areNotificationsEnabled() : _reactNative.PermissionsAndroid.check(_reactNative.PermissionsAndroid.PERMISSIONS.POST_NOTIFICATIONS);
    areEnabledPromise.then(hasPermission => {
      if (hasPermission) {
        this._displayIncomingCallInternal(callID, callerName, message, timeout, appState);
      } else {
        (0, _logger.zlogwarning)(`[NotificationHelper][_displayIncomingCall] displayIncomingCall failed, no permission`);
      }
    });
  }
  _displayIncomingCallInternal(callID, callerName, message, timeout, appState) {
    ZegoUIKitPrebuiltCallRNModule.displayIncomingCall(callID, callerName, message, timeout);
    (0, _logger.zloginfo)(`[NotificationHelper][_displayIncomingCall] displayIncomingCall callID: ${callID}, state: ${appState}`);
    _report.default.reportEvent('call/displayNotification', {
      'call_id': callID,
      'app_state': appState
    });
  }
  dismissNotification(callID, reason, from) {
    (0, _logger.zloginfo)(`[NotificationHelper][dismissNotification] callID: ${callID}, reason: ${reason}, from: ${from}`);
    if (reason === 'BeCancelled' || reason === 'Timeout') {
      if (!callID || callID !== this._currentCallID) {
        (0, _logger.zloginfo)(`[NotificationHelper][dismissNotification] ignore callID: ${callID}`);
        return;
      }
      let notifyUuid = this._callIDUuidMap.get(callID);
      if (notifyUuid) {
        ZegoUIKitPrebuiltCallRNModule.dismissCallNotification();
        this._currentCallID = '';
        this._currentCallStatus = 'waiting';
        (0, _logger.zloginfo)(`[NotificationHelper][dismissNotification] set _currentCallID: ${this._currentCallID}, status: ${this._currentCallStatus}`);
        _report.default.reportEvent('call/respondInvitation', {
          'call_id': callID,
          'app_state': _reactNative.AppState.currentState,
          'action': reason
        });
      }
    } else {
      // Handed over to the active state for handling
      let notifyUuid = this._callIDUuidMap.get(callID);
      if (notifyUuid) {
        ZegoUIKitPrebuiltCallRNModule.dismissCallNotification();
        this._currentCallID = '';
        this._currentCallStatus = 'waiting';
        (0, _logger.zloginfo)(`[NotificationHelper][dismissNotification] set _currentCallID: ${this._currentCallID}, status: ${this._currentCallStatus}`);
      }
    }
  }
  async _onCallKitEndCall(action) {
    if (!this._callData) {
      (0, _logger.zlogerror)('[NotificationHelper][_onCallKitEndCall] _callData is empty');
      return;
    }
    (0, _logger.zloginfo)(`[NotificationHelper][_onCallKitEndCall] callData: ${JSON.stringify(this._callData)}, state: ${_reactNative.AppState.currentState}`);

    // Offline incoming calls are not supported (too early), and online incoming calls rely on ZegoCallInvitationDialog
    // CallEventNotifyApp.getInstance().notifyIncomingCallDeclineButtonPressed()

    // @ts-ignore
    let {
      callID,
      roomID,
      inviter,
      isPureOfflinePush
    } = this._callData;
    this._callData = undefined;
    if (action === 'Timeout') {
      this._whenEndCallFinal();
    } else if (action !== 'Refuse') {
      // Currently, there are only two actions: Timeout and Refuse.
    } else if (isPureOfflinePush) {
      // click decline button from notification
      this._offlineRefuse(callID, roomID, inviter, 'refuse');
    } else {
      // click decline button from notification
      this._onlineRefuse(callID, roomID, inviter);
    }
  }
  _offlineRefuse(callID, roomID, inviter, reason) {
    (0, _logger.zloginfo)('[NotificationHelper][_onCallKitEndCall] loadLoginInfoFromLocalEncryptedStorage');
    _plugins.default.loadLoginInfoFromLocalEncryptedStorage().then(loginInfo => {
      (0, _logger.zloginfo)(`[NotificationHelper][_onCallKitEndCall] will refuse after signalingPlugin login succ, callbackID: ${this._callbackID}`);
      _plugins.default.init(loginInfo.appID, loginInfo.appSign, loginInfo.userID, loginInfo.userName, this._plugins).then(() => {
        this._signalingPlugin.refuseInvitation(inviter.id, JSON.stringify({
          callID,
          call_id: roomID,
          reason,
          'invitee': {
            userID: loginInfo.userID,
            userName: loginInfo.userName
          }
        })).then(result => {
          (0, _logger.zloginfo)(`[NotificationHelper][_onCallKitEndCall] refuseInvitation then, code: ${result.code}, message: ${result.message}`);
          _report.default.reportEvent('call/respondInvitation', {
            'call_id': callID,
            'app_state': 'restarted',
            'action': reason
          });
          _call_invite_helper.default.getInstance().refuseCall(callID);
          this._whenEndCallFinal();
          // In order to continue receiving offline push notifications in the future.
          _zegoUikitRn.default.getSignalingPlugin().uninit();
        }).catch(error => {
          (0, _logger.zloginfo)(`[NotificationHelper][_onCallKitEndCall] refuseInvitation catch, error: ${error.code}, message: ${error.message}`);
          _call_invite_helper.default.getInstance().refuseCall(callID);
          this._whenEndCallFinal();
          // In order to continue receiving offline push notifications in the future.
          _zegoUikitRn.default.getSignalingPlugin().uninit();
        });
      }).catch(() => {
        this._whenEndCallFinal();
      });
    }).catch(() => {
      this._whenEndCallFinal();
    });
  }
  _onlineRefuse(callID, roomID, inviter) {
    this._signalingPlugin.refuseInvitation(inviter.id, JSON.stringify({
      callID,
      call_id: roomID,
      // @ts-ignore
      'invitee': {
        userID: _plugins.default.getLocalUser().userID,
        userName: _plugins.default.getLocalUser().userName
      }
    })).then(result => {
      (0, _logger.zloginfo)(`[NotificationHelper][_onCallKitEndCall] refuseInvitation then, code: ${result.code}, message: ${result.message}`);
      _report.default.reportEvent('call/respondInvitation', {
        'call_id': callID,
        'app_state': _reactNative.AppState.currentState,
        'action': 'refuse'
      });
      _call_invite_helper.default.getInstance().refuseCall(callID);
      this._whenEndCallFinal();
    }).catch(error => {
      (0, _logger.zloginfo)(`[NotificationHelper][_onCallKitEndCall] refuseInvitation catch, error: ${error.code}, message: ${error.message}`);
      _call_invite_helper.default.getInstance().refuseCall(callID);
      this._whenEndCallFinal();
    });
  }
  _whenEndCallFinal() {
    this._currentCallID = '';
    this._currentCallStatus = 'waiting';
    (0, _logger.zloginfo)(`[NotificationHelper][_onCallKitEndCall] set _currentCallID: ${this._currentCallID}, status: ${this._currentCallStatus}`);

    // auto dismiss
    // ZegoUIKitPrebuiltCallRNModule.dismissCallNotification();
  }
  _onCallKitAnswerCall() {
    if (!this._callData) {
      (0, _logger.zlogerror)('[NotificationHelper][_onCallKitAnswerCall] _callData is empty');
      return;
    }
    (0, _logger.zloginfo)(`[NotificationHelper][_onCallKitAnswerCall] callData: ${JSON.stringify(this._callData)}, state: ${_reactNative.AppState.currentState}`);

    // @ts-ignore
    let {
      callID,
      roomID,
      type,
      inviter,
      invitees,
      isPureOfflinePush
    } = this._callData;
    this._callData = undefined;
    let app_state = isPureOfflinePush ? "restarted" : _reactNative.AppState.currentState;
    if (isPureOfflinePush) {
      _call_invite_helper.default.getInstance().setOfflineData({
        call_id: roomID,
        type,
        inviter,
        invitees
      });
    } else {
      (0, _logger.zloginfo)(`[NotificationHelper][_onCallKitAnswerCall] will accept after signalingPlugin login succ, callbackID: ${this._callbackID}`);
      this._signalingPlugin.onLoginSuccess(this._callbackID, () => {
        _call_invite_helper.default.getInstance().acceptCall(callID, {
          call_id: roomID,
          type,
          inviter,
          invitees
        });
        _zegoUikitRn.default.getSignalingPlugin().acceptInvitation(inviter.id, JSON.stringify({
          callID,
          call_id: roomID,
          // @ts-ignore
          'invitee': {
            userID: _plugins.default.getLocalUser().userID,
            userName: _plugins.default.getLocalUser().userName
          }
        })).then(result => {
          (0, _logger.zloginfo)(`[NotificationHelper][_onCallKitAnswerCall] acceptInvitation then, code: ${result.code}, message: ${result.message}`);
          _report.default.reportEvent('call/respondInvitation', {
            'call_id': callID,
            app_state,
            'action': 'accept'
          });
          this._currentCallID = '';
          this._currentCallStatus = 'waiting';
          (0, _logger.zloginfo)(`[NotificationHelper][_onCallKitAnswerCall] set _currentCallID: ${this._currentCallID}, status: ${this._currentCallStatus}`);
          if (_reactNative.AppState.currentState === 'background') {
            this._currentCallID = callID;
            this._currentCallStatus = 'calling';
            (0, _logger.zloginfo)(`[NotificationHelper][_onCallKitAnswerCall] set _currentCallID: ${this._currentCallID}, status: ${this._currentCallStatus}`);
          }
        }).catch(error => {
          (0, _logger.zloginfo)(`[NotificationHelper][_onCallKitAnswerCall] acceptInvitation catch, error: ${error.code}, message: ${error.message}`);
          _call_invite_helper.default.getInstance().refuseCall(callID);
          this._currentCallID = '';
          this._currentCallStatus = 'waiting';
          (0, _logger.zloginfo)(`[NotificationHelper][_onCallKitAnswerCall] set _currentCallID: ${this._currentCallID}, status: ${this._currentCallStatus}`);
        });
      });
    }
  }
  getCurrentInCallID() {
    if (this._currentCallStatus === 'calling') {
      return this._currentCallID;
    } else {
      return '';
    }
  }
}
exports.default = NotificationHelper;
_NotificationHelper = NotificationHelper;
_defineProperty(NotificationHelper, "_instance", void 0);
//# sourceMappingURL=notification_helper.android.js.map