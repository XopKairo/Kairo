"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _reactNative = require("react-native");
var _reactNativeSound = require("react-native-sound");
var _reactNativeUuid = _interopRequireDefault(require("react-native-uuid"));
var _zegoUikitRn = _interopRequireDefault(require("@zegocloud/zego-uikit-rn"));
var _services = _interopRequireDefault(require("../../services"));
var _logger = require("../../utils/logger");
var _report = _interopRequireDefault(require("../../utils/report"));
var _call_invite_helper = _interopRequireDefault(require("./call_invite_helper"));
var _defines = require("./defines");
var _inner_text_helper = _interopRequireDefault(require("./inner_text_helper"));
var _plugins = _interopRequireDefault(require("./plugins"));
var _NotificationHelper;
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); } // @ts-ignore
class NotificationHelper {
  constructor() {
    _defineProperty(this, "TAG", 'NotificationHelper');
    _defineProperty(this, "_signalingPlugin", _zegoUikitRn.default.getSignalingPlugin());
    _defineProperty(this, "_uikitSignalingPlugin", _zegoUikitRn.default.getSignalingPlugin().getZegoUIKitSignalingPlugin().getInstance());
    _defineProperty(this, "_callbackID", `${this.TAG}_${String(Math.floor(Math.random() * 10000))}`);
    _defineProperty(this, "_callData", {});
    _defineProperty(this, "_callIDUuidMap", new Map());
    _defineProperty(this, "_currentCallID", '');
    _defineProperty(this, "_currentCallStatus", 'waiting');
    _reactNative.AppState.addEventListener('change', async nextState => {
      (0, _logger.zloginfo)('nextState', nextState);
      if (nextState === 'active') {
        this.dismissNotification(this._currentCallID, 'active', this.TAG);
      }
    });
  }
  static getInstance() {
    return this._instance || (this._instance = new NotificationHelper());
  }
  init() {
    (0, _logger.zloginfo)(`[NotificationHelper][init]`);
    this._uikitSignalingPlugin.onCallKitEndCall(this._onCallKitEndCall.bind(this));
    (0, _logger.zloginfo)(`[NotificationHelper][init] set onCallKitEndCall`);
    this._uikitSignalingPlugin.onCallKitAnswerCall(this._onCallKitAnswerCall.bind(this));
    (0, _logger.zloginfo)(`[NotificationHelper][init] set onCallKitAnswerCall`);
  }

  // for offline call
  showOfflineNotification(callID, callUUID, callData) {
    if (!callData) {
      (0, _logger.zlogerror)('[NotificationHelper][showOfflineNotification] callData is empty');
      return;
    }
    (0, _logger.zloginfo)(`[NotificationHelper][showOfflineNotification] callID: ${callID}, callUUID: ${callUUID}, callData: ${JSON.stringify(callData)}`);
    let notifyUuid = this._callIDUuidMap.get(callID);
    if (notifyUuid) {
      (0, _logger.zloginfo)(`[NotificationHelper][showOfflineNotification] callID: ${callID} ignore, already shown notification`);
      this._uikitSignalingPlugin.reportCallKitCallEnded(callUUID, 2); // 2 - RemoteEnded
      return;
    }
    this._callIDUuidMap.set(callID, callUUID);
    let {
      call_id: roomID,
      type,
      inviter,
      invitees
    } = callData;
    if (this._currentCallID && this._currentCallStatus === 'notification') {
      (0, _logger.zloginfo)(`[NotificationHelper][showOfflineNotification] another call is showing`);
      this._refuse(undefined, callID, roomID, inviter, 'busy', 'restarted');
      this._uikitSignalingPlugin.reportCallKitCallEnded(callUUID, 2); // 2 - RemoteEnded

      _report.default.reportEvent('call/respondInvitation', {
        'call_id': callID,
        'app_state': 'restarted',
        'action': 'busy'
      });
      return;
    }
    this._currentCallID = callID;
    this._currentCallStatus = 'notification';
    (0, _logger.zloginfo)(`[NotificationHelper][showOfflineNotification] set _currentCallID: ${this._currentCallID}, status: ${this._currentCallStatus}`);
    (0, _logger.zloginfo)(`[NotificationHelper][showOfflineNotification] displayIncomingCall callID: ${callID}`);

    // callID mean zim callID
    this._callData = {
      callID,
      roomID,
      type,
      inviter,
      invitees,
      isPureOfflinePush: true
    };
    (0, _logger.zloginfo)(`[NotificationHelper][showOfflineNotification] _callData: ${JSON.stringify(this._callData)}`);
  }

  // for online call when background
  showOnlineNotification(callID, callData) {
    let notifyUuid = this._callIDUuidMap.get(callID);
    if (notifyUuid) {
      (0, _logger.zloginfo)(`[NotificationHelper][showOnlineNotification] callID: ${callID} ignore, already shown notification`);
      return;
    }
    if (!callData) {
      (0, _logger.zlogerror)('[NotificationHelper][showOnlineNotification] _callData is empty');
      return;
    }

    // @ts-ignore
    let {
      roomID,
      type,
      inviter,
      invitees
    } = callData;
    (0, _logger.zloginfo)(`[NotificationHelper][showOnlineNotification] callID: ${callID}, roomID: ${roomID}, isVideoCall: ${type}, inviter: ${JSON.stringify(inviter)}, invitees: ${JSON.stringify(invitees)}`);
    notifyUuid = _reactNativeUuid.default.v4();
    (0, _logger.zloginfo)(`[NotificationHelper][showOnlineNotification] reportIncomingCall callID: ${callID}, uuid: ${notifyUuid}`);
    const callerName = _inner_text_helper.default.instance().getIncomingCallDialogTitle(inviter.name, type, invitees.length);
    (0, _logger.zloginfo)(`[NotificationHelper][showOnlineNotification], callerName: ${callerName}`);
    let cxCallUpdate = {};
    cxCallUpdate.localizedCallerName = callerName;
    cxCallUpdate.hasVideo = type === _defines.ZegoInvitationType.videoCall;
    this._uikitSignalingPlugin.reportIncomingCall(cxCallUpdate, notifyUuid).then(() => {
      (0, _logger.zloginfo)(`[NotificationHelper][showOnlineNotification] reportIncomingCall succeeded, callID: ${callID}`);
    }).catch(message => {
      (0, _logger.zlogerror)(`[NotificationHelper][showOnlineNotification] reportIncomingCall failed, reason: ${message}`);
    });
    this._currentCallID = callID;
    this._currentCallStatus = 'notification';
    (0, _logger.zloginfo)(`[NotificationHelper][showOnlineNotification] set _currentCallID: ${this._currentCallID}, status: ${this._currentCallStatus}`);
    this._callIDUuidMap.set(callID, notifyUuid);
    (0, _logger.zloginfo)(`[NotificationHelper][showOnlineNotification] set ${callID} into _callIDUuidMap`);
    _report.default.reportEvent('call/displayNotification', {
      'call_id': callID,
      'app_state': _reactNative.AppState.currentState
    });
    this._callData = {
      callID,
      roomID,
      type,
      inviter,
      invitees
    };
    (0, _logger.zloginfo)(`[NotificationHelper][showOnlineNotification] _callData: ${JSON.stringify(this._callData)}`);
  }
  dismissNotification(callID, reason, from) {
    (0, _logger.zloginfo)(`[NotificationHelper][dismissNotification] callID: ${callID}, reason: ${reason}, from: ${from}`);
    if (reason === 'active') {
      // Handed over to the active state for handling
      let notifyUuid = this._callIDUuidMap.get(callID);
      if (notifyUuid) {
        this._uikitSignalingPlugin.reportCallKitCallEnded(notifyUuid, 2); // 2 - RemoteEnded
        this._currentCallID = '';
        this._currentCallStatus = 'waiting';
        (0, _logger.zloginfo)(`[NotificationHelper][dismissNotification] set _currentCallID: ${this._currentCallID}, status: ${this._currentCallStatus}`);
      }
    } else if (reason === 'BeCancelled' || reason === 'Timeout') {
      if (!callID || callID !== this._currentCallID) {
        (0, _logger.zloginfo)(`[NotificationHelper][dismissNotification] ignore callID: ${callID}`);
        return;
      }
      let notifyUuid = this._callIDUuidMap.get(callID);
      if (notifyUuid) {
        this._uikitSignalingPlugin.reportCallKitCallEnded(notifyUuid, 2); // 2 - RemoteEnded
        this._currentCallID = '';
        this._currentCallStatus = 'waiting';
        (0, _logger.zloginfo)(`[NotificationHelper][dismissNotification] set _currentCallID: ${this._currentCallID}, status: ${this._currentCallStatus}`);
        _report.default.reportEvent('call/respondInvitation', {
          'call_id': callID,
          'app_state': _reactNative.AppState.currentState,
          'action': reason
        });
      }
    }
  }
  _onCallKitEndCall(action) {
    if (!this._callData) {
      (0, _logger.zlogerror)('[NotificationHelper][_onCallKitEndCall] _callData is empty');
      return;
    }
    (0, _logger.zloginfo)(`[NotificationHelper][_onCallKitEndCall] callData: ${JSON.stringify(this._callData)}, state: ${_reactNative.AppState.currentState}`);

    // Offline incoming calls are not supported (too early), and online incoming calls rely on ZegoCallInvitationDialog
    // CallEventNotifyApp.getInstance().notifyIncomingCallDeclineButtonPressed()

    if (this._currentCallID && this._currentCallStatus === 'calling') {
      // click accept and hangup
      this.hangUp(this._currentCallID, 'onCallKitEndCall');
      (0, _logger.zloginfo)(`[NotificationHelper][_onCallKitEndCall] hangUp`);
      this._currentCallID = '';
      this._currentCallStatus = 'waiting';
      (0, _logger.zloginfo)(`[NotificationHelper][_onCallKitEndCall] set _currentCallID: ${this._currentCallID}, status: ${this._currentCallStatus}`);
      action.fulfill();
    } else {
      // click decline button from notification

      // @ts-ignore
      let {
        callID,
        roomID,
        inviter
      } = this._callData;
      this._callData = undefined;
      (0, _logger.zloginfo)(`[NotificationHelper][_onCallKitEndCall] will refuse after signalingPlugin login succ, callbackID: ${this._callbackID}`);
      this._refuse(action, callID, roomID, inviter, 'refuse', _reactNative.AppState.currentState);
    }
  }
  _refuse(action, callID, roomID, inviter, reason, appState) {
    this._signalingPlugin.onLoginSuccess(this._callbackID, () => {
      // tell caller
      this._signalingPlugin.refuseInvitation(inviter.id, JSON.stringify({
        callID,
        call_id: roomID,
        // @ts-ignore
        'invitee': {
          userID: _plugins.default.getLocalUser().userID,
          userName: _plugins.default.getLocalUser().userName
        }
      })).then(result => {
        (0, _logger.zloginfo)(`[NotificationHelper][_onCallKitEndCall] refuseInvitation then, code: ${result.code}, message: ${result.message}`);
        _report.default.reportEvent('call/respondInvitation', {
          'call_id': callID,
          'app_state': appState,
          'action': reason
        });
        _call_invite_helper.default.getInstance().refuseCall(callID);
        this._currentCallID = '';
        this._currentCallStatus = 'waiting';
        (0, _logger.zloginfo)(`[NotificationHelper][_onCallKitEndCall] set _currentCallID: ${this._currentCallID}, status: ${this._currentCallStatus}`);

        // tell ios decline completion
        if (action) {
          action.fulfill();
        }
      }).catch(error => {
        (0, _logger.zloginfo)(`[NotificationHelper][_onCallKitEndCall] refuseInvitation catch, error: ${error.code}, message: ${error.message}`);
        _call_invite_helper.default.getInstance().refuseCall(callID);
        this._currentCallID = '';
        this._currentCallStatus = 'waiting';
        (0, _logger.zloginfo)(`[NotificationHelper][_onCallKitEndCall] set _currentCallID: ${this._currentCallID}, status: ${this._currentCallStatus}`);

        // tell ios decline fail
        if (action) {
          action.fail();
        }
      });
      this._signalingPlugin.onLoginSuccess(this._callbackID);
    });
  }
  _onCallKitAnswerCall(action) {
    if (!this._callData) {
      (0, _logger.zlogerror)('[NotificationHelper][_onCallKitAnswerCall] _callData is empty');
      return;
    }
    (0, _logger.zloginfo)(`[NotificationHelper][_onCallKitAnswerCall] callData: ${JSON.stringify(this._callData)}, state: ${_reactNative.AppState.currentState}`);

    // @ts-ignore
    let {
      callID,
      roomID,
      type,
      inviter,
      invitees,
      isPureOfflinePush
    } = this._callData;
    // this._callData = undefined   // Do not clear it, as it will still be needed when the VoIP call is hangup later.

    (0, _logger.zloginfo)(`[NotificationHelper][_onCallKitAnswerCall] will accept after signalingPlugin login succ, callbackID: ${this._callbackID}`);
    this._signalingPlugin.onLoginSuccess(this._callbackID, () => {
      let app_state = _reactNative.AppState.currentState;
      if (isPureOfflinePush) {
        _call_invite_helper.default.getInstance().setOfflineData({
          call_id: roomID,
          type,
          inviter,
          invitees
        });
        app_state = "restarted";
      }
      (0, _reactNativeSound.setCategory)('PlayAndRecord');
      _call_invite_helper.default.getInstance().acceptCall(callID, {
        call_id: roomID,
        type,
        inviter,
        invitees
      });
      _zegoUikitRn.default.getSignalingPlugin().acceptInvitation(inviter.id, JSON.stringify({
        callID,
        call_id: roomID,
        // @ts-ignore
        'invitee': {
          userID: _plugins.default.getLocalUser().userID,
          userName: _plugins.default.getLocalUser().userName
        }
      })).then(result => {
        (0, _logger.zloginfo)(`[NotificationHelper][_onCallKitAnswerCall] acceptInvitation then, code: ${result.code}, message: ${result.message}`);
        _report.default.reportEvent('call/respondInvitation', {
          'call_id': callID,
          app_state,
          'action': 'accept'
        });
        this._currentCallID = '';
        this._currentCallStatus = 'waiting';
        (0, _logger.zloginfo)(`[NotificationHelper][_onCallKitAnswerCall] set _currentCallID: ${this._currentCallID}, status: ${this._currentCallStatus}`);
        if (_reactNative.AppState.currentState === 'background') {
          this._currentCallID = callID;
          this._currentCallStatus = 'calling';
          (0, _logger.zloginfo)(`[NotificationHelper][_onCallKitAnswerCall] set _currentCallID: ${this._currentCallID}, status: ${this._currentCallStatus}`);
        }
        action.fulfill();
      }).catch(error => {
        (0, _logger.zloginfo)(`[NotificationHelper][_onCallKitAnswerCall] acceptInvitation catch, error: ${error.code}, message: ${error.message}`);
        this.hangUp(callID, 'acceptFailed');
        _call_invite_helper.default.getInstance().refuseCall(callID);
        this._currentCallID = '';
        this._currentCallStatus = 'waiting';
        (0, _logger.zloginfo)(`[NotificationHelper][_onCallKitAnswerCall] set _currentCallID: ${this._currentCallID}, status: ${this._currentCallStatus}`);

        // tell ios decline fail
        action.fail();
      });
    });
  }
  hangUp(callID, reason) {
    (0, _logger.zloginfo)(`[NotificationHelper][hangUp] callID: ${callID}, reason: ${reason}`);
    if (reason === 'onCallKitEndCall' || reason === 'acceptFailed') {
      _services.default.getInstance().hangUp();
    } else {
      let notifyUuid = this._callIDUuidMap.get(callID);
      if (notifyUuid) {
        this._uikitSignalingPlugin.reportCallKitCallEnded(notifyUuid, 2); // 2 - RemoteEnded
        this._currentCallID = '';
        this._currentCallStatus = 'waiting';
        (0, _logger.zloginfo)(`[NotificationHelper][hangUp] set _currentCallID: ${this._currentCallID}, status: ${this._currentCallStatus}`);
      }
    }
  }
  getCurrentInCallID() {
    if (this._currentCallStatus === 'calling') {
      return this._currentCallID;
    } else {
      return '';
    }
  }
}
exports.default = NotificationHelper;
_NotificationHelper = NotificationHelper;
_defineProperty(NotificationHelper, "_instance", void 0);
//# sourceMappingURL=notification_helper.ios.js.map