"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _zegoUikitRn = _interopRequireDefault(require("@zegocloud/zego-uikit-rn"));
var _plugins = _interopRequireDefault(require("./plugins"));
var _logger = require("../../utils/logger");
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
// completed: Someone ran out of time, accepted or declined an invitation
// uncompleted: Others did not accept or reject the invitation, and the invitation did not time out

// Consider having multiple call invitation processes at the same time

const InviteState = {
  uncompleted: 1,
  // inviter: send an invitation、init state
  completed: 2,
  // inviter: send an invitation
  pending: 3,
  // invitee: call pending、init state
  accepted: 4,
  // invitee: accept
  missed: 5,
  // invitee: timout
  rejected: 6 // invitee: rejection
};
const CallInviteStateManage = {
  _callbackID: '',
  _invitationMap: new Map(),
  // callID -> state detail
  _onInviteCompletedWithNobodyMap: new Map(),
  _onSomeoneAcceptedInviteMap: new Map(),
  // Set to true when making an outgoing call, and reset to false after the call is answered or canceled
  _inOutgoingCall: false,
  _notifyInviteCompletedWithNobody: callID => {
    const stateDetails = CallInviteStateManage._invitationMap.get(callID);
    if (stateDetails) {
      (0, _logger.zloginfo)('######_notifyInviteCompletedWithNobody######', callID, CallInviteStateManage._invitationMap);
      const completedWithNobody = stateDetails.inviteState === InviteState.completed && !Array.from(stateDetails.invitees.values()).find(inviteState => inviteState === InviteState.accepted);
      if (completedWithNobody) {
        // notify
        Array.from(CallInviteStateManage._onInviteCompletedWithNobodyMap.values()).forEach(callback => {
          callback && callback(callID);
        });
      }
    }
  },
  _judgeInviteCompleted: callID => {
    const inviteDetails = CallInviteStateManage._invitationMap.get(callID);
    return !Array.from(inviteDetails.invitees.values()).find(inviteState => inviteState === InviteState.pending);
  },
  init: () => {
    CallInviteStateManage.registerCallback();
  },
  uninit: () => {
    CallInviteStateManage.unRegisterCallback();
    CallInviteStateManage._invitationMap.clear();
    CallInviteStateManage._onInviteCompletedWithNobodyMap.clear();
    CallInviteStateManage._onSomeoneAcceptedInviteMap.clear();
    (0, _logger.zloginfo)('[CallInviteStateManage][uninit]');
  },
  registerCallback: () => {
    (0, _logger.zloginfo)('[CallInviteStateManage]registerCallback success');
    CallInviteStateManage._callbackID = 'CallInviteStateManage' + String(Math.floor(Math.random() * 10000));
    _zegoUikitRn.default.getSignalingPlugin().onInvitationResponseTimeout(CallInviteStateManage._callbackID, ({
      callID,
      invitees,
      data
    }) => {
      // update _invitationMap
      const inviteDetails = CallInviteStateManage._invitationMap.get(callID);
      if (inviteDetails) {
        (0, _logger.zloginfo)(`[InviteStateManage][onInvitationResponseTimeout], callID: ${callID}, inviteDetails: ${inviteDetails}`);
        invitees.forEach(invitee => {
          inviteDetails.invitees.set(invitee.id, InviteState.missed);
        });
        inviteDetails.inviteState = CallInviteStateManage._judgeInviteCompleted(callID) ? InviteState.completed : InviteState.uncompleted;
        (0, _logger.zloginfo)(`[InviteStateManage][onInvitationResponseTimeout], callID: ${callID}, set inviteState: ${inviteDetails.inviteState}`);
        CallInviteStateManage._notifyInviteCompletedWithNobody(callID);
      }
    });
    _zegoUikitRn.default.getSignalingPlugin().onInvitationRefused(CallInviteStateManage._callbackID, ({
      callID,
      invitee,
      data
    }) => {
      // update _invitationMap
      const inviteDetails = CallInviteStateManage._invitationMap.get(callID);
      if (inviteDetails) {
        inviteDetails.invitees.set(invitee.id, InviteState.rejected);
        let isInviteCompleted = CallInviteStateManage._judgeInviteCompleted(callID);
        (0, _logger.zloginfo)(`[InviteStateManage][onInvitationRefused] isInviteCompleted: ${isInviteCompleted}`);
        inviteDetails.inviteState = isInviteCompleted ? InviteState.completed : InviteState.uncompleted;
        CallInviteStateManage._notifyInviteCompletedWithNobody(callID);
      }
    });
    _zegoUikitRn.default.getSignalingPlugin().onInvitationAccepted(CallInviteStateManage._callbackID, ({
      callID,
      invitee,
      data
    }) => {
      // update _invitationMap
      (0, _logger.zloginfo)('######onInvitationAccepted######', CallInviteStateManage._invitationMap, callID);
      const inviteDetails = CallInviteStateManage._invitationMap.get(callID);
      if (inviteDetails) {
        inviteDetails.invitees.set(invitee.id, InviteState.accepted);
        inviteDetails.inviteState = CallInviteStateManage._judgeInviteCompleted(callID) ? InviteState.completed : InviteState.uncompleted;
        // notify
        Array.from(CallInviteStateManage._onSomeoneAcceptedInviteMap.values()).forEach(callback => {
          callback && callback(callID);
        });
      }
    });
    _zegoUikitRn.default.getSignalingPlugin().onInvitationReceived(CallInviteStateManage._callbackID, ({
      callID,
      type,
      inviter,
      data
    }) => {
      (0, _logger.zloginfo)(`onInvitationReceived implement by ${TAG}, callID: ${callID}, inviter: ${JSON.stringify(inviter)}, data: ${data}`);
      data = JSON.parse(data);
      // update _invitationMap
      const inviteDetails = CallInviteStateManage._invitationMap.get(callID);
      if (inviteDetails) {
        // No such case
      } else {
        CallInviteStateManage.addInviteData(callID, inviter.id, data.invitees.map(invitee => invitee.user_id));
      }
    }, TAG);
    _zegoUikitRn.default.getSignalingPlugin().onInvitationCanceled(CallInviteStateManage._callbackID, ({
      callID,
      inviter,
      data
    }) => {
      // update _invitationMap
      CallInviteStateManage._invitationMap.delete(callID);
    });
    _zegoUikitRn.default.getSignalingPlugin().onInvitationTimeout(CallInviteStateManage._callbackID, ({
      callID,
      inviter,
      data
    }) => {
      // update _invitationMap
      const inviteDetails = CallInviteStateManage._invitationMap.get(callID);
      if (inviteDetails) {
        const localUser = _plugins.default.getLocalUser();
        inviteDetails.invitees.set(localUser.userID, InviteState.missed);
      } else {
        // No such case
      }
    });
  },
  unRegisterCallback: () => {
    _zegoUikitRn.default.getSignalingPlugin().onInvitationResponseTimeout(CallInviteStateManage._callbackID);
    _zegoUikitRn.default.getSignalingPlugin().onInvitationRefused(CallInviteStateManage._callbackID);
    _zegoUikitRn.default.getSignalingPlugin().onInvitationAccepted(CallInviteStateManage._callbackID);
    _zegoUikitRn.default.getSignalingPlugin().onInvitationReceived(CallInviteStateManage._callbackID);
    _zegoUikitRn.default.getSignalingPlugin().onInvitationCanceled(CallInviteStateManage._callbackID);
    _zegoUikitRn.default.getSignalingPlugin().onInvitationTimeout(CallInviteStateManage._callbackID);
  },
  // This call is called after the call invitation has ended or before an invitation starts
  initInviteData: () => {
    (0, _logger.zloginfo)('[CallInviteStateManage][initInviteData]');
    CallInviteStateManage._invitationMap.clear();
  },
  setOutgoingCallStatus: isInviteCalling => {
    (0, _logger.zloginfo)('[CallInviteStateManage][setOutgoingCallStatus]', isInviteCalling);
    CallInviteStateManage._inOutgoingCall = isInviteCalling;
  },
  // This interface is called after the invitation is received and the invitation is successfully sent
  addInviteData: (invitationID, inviterID, invitees) => {
    const temp = new Map();
    invitees.forEach(inviteeID => {
      temp.set(inviteeID, InviteState.pending);
    });
    CallInviteStateManage._invitationMap.set(invitationID, {
      inviterID,
      inviteState: InviteState.uncompleted,
      invitees: temp
    });
    (0, _logger.zloginfo)('[CallInviteStateManage][addInviteData]', JSON.stringify(...CallInviteStateManage._invitationMap));
  },
  // This interface is called after the invitation is successfully rejected
  updateInviteDataAfterRejected: callID => {
    // update _invitationMap
    CallInviteStateManage._invitationMap.delete(callID);
    (0, _logger.zloginfo)('[CallInviteStateManage][updateInviteDataAfterRejected]', JSON.stringify(...CallInviteStateManage._invitationMap));
  },
  // This interface is called after the invitation is successfully accepted
  updateInviteDataAfterAccepted: invitationID => {
    // update _invitationMap
    const localUser = _plugins.default.getLocalUser();
    const inviteDetails = CallInviteStateManage._invitationMap.get(invitationID);
    if (inviteDetails) {
      inviteDetails.invitees.set(localUser.userID, InviteState.accepted);
    }
    (0, _logger.zloginfo)('[CallInviteStateManage][updateInviteDataAfterAccepted]', JSON.stringify(...CallInviteStateManage._invitationMap));
  },
  // This interface is called after the invitation is successfully cancel
  updateInviteDataAfterCancel: invitationID => {
    // update _invitationMap
    CallInviteStateManage._invitationMap.delete(invitationID);
    (0, _logger.zloginfo)('[CallInviteStateManage][updateInviteDataAfterCancel]', JSON.stringify(...CallInviteStateManage._invitationMap));
  },
  isInviteCompleted: invitationID => {
    const inviteDetails = CallInviteStateManage._invitationMap.get(invitationID);
    if (inviteDetails) {
      return inviteDetails.inviteState === InviteState.completed;
    } else {
      return false;
    }
  },
  isAutoCancelInvite: invitationID => {
    (0, _logger.zloginfo)('######isAutoCancelInvite######', invitationID, CallInviteStateManage._invitationMap);
    let auto = false;
    if (!CallInviteStateManage.isInviteCompleted(invitationID)) {
      const inviteDetails = CallInviteStateManage._invitationMap.get(invitationID);
      if (inviteDetails) {
        const temp = Array.from(inviteDetails.invitees.values());
        if (!temp.find(inviteState => inviteState === InviteState.accepted || inviteState === InviteState.rejected)) {
          // Scene1: When no one clicks accept or reject
          auto = true;
        } else if (!temp.find(inviteState => inviteState === InviteState.accepted) && temp.filter(inviteState => inviteState === InviteState.rejected).length < temp.length) {
          // Scene2: No one accepts, only some people refuse
          auto = true;
        }
      }
    }
    return auto;
  },
  // Determine whether a call is being made
  isOncall: newCallID => {
    let localUserID = _plugins.default.getLocalUser().userID;
    (0, _logger.zloginfo)('[InviteStateManage]######isOncall######', newCallID);

    // determine for onInvitationReceived
    if (newCallID && CallInviteStateManage._inOutgoingCall) {
      isOn = true;
      (0, _logger.zloginfo)(`[InviteStateManage][isOncall] isOn: ${isOn}, reason: _inOutgoingCall === true`);
      return isOn;
    }
    (0, _logger.zloginfo)(`[InviteStateManage][isOncall] _invitationMap.size: ${CallInviteStateManage._invitationMap.size}, _invitationMap: ${JSON.stringify(...CallInviteStateManage._invitationMap)}`);
    let isOn = false;
    const callIDs = Array.from(CallInviteStateManage._invitationMap.keys());
    for (let index = 0, len = callIDs.length; index < len; index++) {
      const currentCallID = callIDs[index];
      if (currentCallID !== newCallID) {
        const stateDetails = CallInviteStateManage._invitationMap.get(currentCallID);
        if (!stateDetails) {
          continue;
        }
        if (stateDetails.inviterID === localUserID && stateDetails.inviteState == InviteState.uncompleted) {
          isOn = true;
          (0, _logger.zloginfo)(`[InviteStateManage][isOncall] isOn: ${isOn}, reason: stateDetails.inviterID === localUserID, stateDetails: ${currentCallID} ${JSON.stringify(stateDetails)}`);
          break;
        }
        const inviteState = stateDetails.invitees.get(localUserID);
        if (inviteState === InviteState.pending || inviteState === InviteState.accepted) {
          isOn = true;
          (0, _logger.zloginfo)(`[InviteStateManage][isOncall] isOn: ${isOn}, reason: localUserID pending or accepted, stateDetails: ${currentCallID} ${JSON.stringify(stateDetails)}`);
          break;
        }
      }
    }
    (0, _logger.zloginfo)(`[InviteStateManage][isOncall] isOn: ${isOn}`);
    return isOn;
  },
  onSomeoneAcceptedInvite: (callbackID, callback) => {
    if (typeof callback !== 'function') {
      if (CallInviteStateManage._onSomeoneAcceptedInviteMap.has(callbackID)) {
        CallInviteStateManage._onSomeoneAcceptedInviteMap.delete(callbackID);
      }
    } else {
      CallInviteStateManage._onSomeoneAcceptedInviteMap.set(callbackID, callback);
    }
  },
  onInviteCompletedWithNobody: (callbackID, callback) => {
    if (typeof callback !== 'function') {
      if (CallInviteStateManage._onInviteCompletedWithNobodyMap.has(callbackID)) {
        CallInviteStateManage._onInviteCompletedWithNobodyMap.delete(callbackID);
      }
    } else {
      CallInviteStateManage._onInviteCompletedWithNobodyMap.set(callbackID, callback);
    }
  }
};
var _default = exports.default = CallInviteStateManage;
const TAG = 'invite_state_manager';
//# sourceMappingURL=invite_state_manager.js.map