"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = ZegoUIKitPrebuiltCallFloatingMinimizedView;
var _react = _interopRequireWildcard(require("react"));
var _reactNative = require("react-native");
var _zegoUikitRn = _interopRequireWildcard(require("@zegocloud/zego-uikit-rn"));
var _defines = require("../services/defines");
var _timing_helper = _interopRequireDefault(require("../services/timing_helper"));
var _logger = require("../utils/logger");
var _minimizing_helper = _interopRequireDefault(require("./services/minimizing_helper"));
var _prebuilt_helper = _interopRequireDefault(require("./services/prebuilt_helper"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
function _extends() { return _extends = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]); } return n; }, _extends.apply(null, arguments); }
function ZegoUIKitPrebuiltCallFloatingMinimizedView(props) {
  const window = (0, _reactNative.useWindowDimensions)();
  const {
    width = 90,
    height = 160,
    borderRadius = 10,
    left = window.width / 2 || 100,
    top = 10,
    showSoundWaveInAudioMode = true,
    useVideoViewAspectFill = true
  } = props;
  const [isInit, setIsInit] = (0, _react.useState)(false);
  const [isVisable, setIsVisable] = (0, _react.useState)(false);
  const [layout, setLayout] = (0, _react.useState)({
    left,
    top
  });
  const [floatViewInfo, setFloatViewInfo] = (0, _react.useState)({
    width: 0,
    height: 0
  });
  const [activeUserID, setActiveUserID] = (0, _react.useState)('');
  const [isMoving, setIsMoving] = (0, _react.useState)(false);
  const panResponder = _reactNative.PanResponder.create({
    onStartShouldSetPanResponder: (evt, gestureState) => true,
    onMoveShouldSetPanResponder: (evt, gestureState) => true,
    onPanResponderGrant: (evt, gestureState) => {
      (0, _logger.zloginfo)('[ZegoUIKitPrebuiltCallFloatingMinimizedView] onPanResponderGrant gestureState', gestureState);
      setIsMoving(false);
    },
    onPanResponderMove: (evt, gestureState) => {
      // zloginfo('[ZegoUIKitPrebuiltCallFloatingMinimizedView] onPanResponderMove layout', layout);
      // zloginfo('[ZegoUIKitPrebuiltCallFloatingMinimizedView] onPanResponderMove gestureState', gestureState);
      if (Math.abs(gestureState.dx) < 5 && Math.abs(gestureState.dy) < 5 && !isMoving) {
        setIsMoving(false);
      } else {
        setIsMoving(true);
        const newLeft = layout.left + gestureState.dx;
        const newTop = layout.top + gestureState.dy;
        if (newLeft >= window.width - floatViewInfo.width || newTop >= window.height - floatViewInfo.height || newLeft <= 0 || newTop <= 0) return;
        setLayout({
          left: newLeft,
          top: newTop
        });
      }
    },
    onPanResponderEnd: (evt, gestureState) => {
      (0, _logger.zloginfo)('[ZegoUIKitPrebuiltCallFloatingMinimizedView] onPanResponderEnd layout', layout);
      (0, _logger.zloginfo)('[ZegoUIKitPrebuiltCallFloatingMinimizedView] onPanResponderEnd gestureState', gestureState);
    },
    onPanResponderRelease: () => {
      if (!isMoving) {
        // Click
        pressedHandle();
      }
      setIsMoving(false);
    }
  });
  const callbackID = 'ZegoMinimizeRoom' + String(Math.floor(Math.random() * 10000));
  const layoutHandle = (0, _react.useCallback)(e => {
    const {
      x,
      y,
      width,
      height
    } = e.nativeEvent.layout;
    setFloatViewInfo({
      width,
      height
    });
  }, []);
  const pressedHandle = async () => {
    (0, _logger.zloginfo)('[ZegoUIKitPrebuiltCallFloatingMinimizedView] pressedHandle');
    _minimizing_helper.default.getInstance().notifyMaximize();
  };
  (0, _react.useEffect)(() => {
    _minimizing_helper.default.getInstance().onPrebuiltInit(callbackID, () => {
      (0, _logger.zloginfo)('[ZegoUIKitPrebuiltCallFloatingMinimizedView] init success');
      setIsInit(true);
    });
    _timing_helper.default.getInstance().onDurationUpdate(callbackID, duration => {
      const isMinimize = _minimizing_helper.default.getInstance().getIsMinimize();
      let routeParams = _prebuilt_helper.default.getInstance().getRouteParams();
      if (isMinimize && typeof routeParams.onDurationUpdate == 'function') {
        routeParams.onDurationUpdate(duration);
      }
    });
    return () => {
      // It will never be executed because this view is persistent.
      _minimizing_helper.default.getInstance().onPrebuiltInit(callbackID);
      _timing_helper.default.getInstance().onDurationUpdate(callbackID);
    };
  }, []);
  (0, _react.useEffect)(() => {
    if (isInit) {
      _minimizing_helper.default.getInstance().onWindowMinimized(callbackID, () => {
        const initConfig = _minimizing_helper.default.getInstance().getInitConfig();
        const {
          onWindowMinimized
        } = initConfig;
        if (typeof onWindowMinimized !== 'function') {
          (0, _logger.zloginfo)('[ZegoUIKitPrebuiltCallFloatingMinimizedView][onWindowMinimized] onWindowMinimized is not a function, ignore call it');
          return;
        }
        (0, _logger.zloginfo)('[ZegoUIKitPrebuiltCallFloatingMinimizedView][onWindowMinimized]');
        setIsVisable(true);
        _minimizing_helper.default.getInstance().setIsMinimizeSwitch(true, 'onWindowMinimized');
        (0, _logger.zloginfo)('[ZegoUIKitPrebuiltCallFloatingMinimizedView][onWindowMinimized] execute requireConfig.onWindowMinimized will');
        onWindowMinimized();
        (0, _logger.zloginfo)('[ZegoUIKitPrebuiltCallFloatingMinimizedView][onWindowMinimized] execute requireConfig.onWindowMinimized succeed');
        setTimeout(() => {
          _zegoUikitRn.default.forceRenderVideoView();
        }, 100);
      });
      _minimizing_helper.default.getInstance().onWindowMaximized(callbackID, () => {
        (0, _logger.zloginfo)('[ZegoUIKitPrebuiltCallFloatingMinimizedView][onWindowMaximized]');
        setIsVisable(false);
        const initConfig = _minimizing_helper.default.getInstance().getInitConfig();
        const {
          onWindowMaximized
        } = initConfig;
        const routeParams = _prebuilt_helper.default.getInstance().getRouteParams();
        // if routeParams is empty, do not call onWindowMaximized, to avoid exception in ZegoUIKitPrebuiltCallInCallScreen
        // In MinimizeSwitch mode, MinimizeView will gone after clearRouteParams
        if (typeof onWindowMaximized === 'function' && Object.keys(routeParams).length > 0) {
          (0, _logger.zloginfo)('[ZegoUIKitPrebuiltCallFloatingMinimizedView][onWindowMaximized] execute initConfig.onWindowMaximized will');
          onWindowMaximized();
          (0, _logger.zloginfo)('[ZegoUIKitPrebuiltCallFloatingMinimizedView][onWindowMaximized] execute initConfig.onWindowMaximized succeed');
          _minimizing_helper.default.getInstance().setIsMinimizeSwitch(true, 'onWindowMaximized');
        } else {
          (0, _logger.zloginfo)('[ZegoUIKitPrebuiltCallFloatingMinimizedView][onWindowMaximized] onWindowMaximized not a function or routeParams is empty');
          // Since the room can't be restored and the option to maximize the entrance has already invisable, to avoid exception leater, the minimized state should be restored to false.
          _minimizing_helper.default.getInstance().setIsMinimizeSwitch(false, 'onWindowMaximized not a function');
        }
      });
      _minimizing_helper.default.getInstance().onEntryNormal(callbackID, () => {
        setIsVisable(false);
      });
      _minimizing_helper.default.getInstance().onActiveUserIDUpdate(callbackID, activeUserID => {
        // zloginfo(`[ZegoUIKitPrebuiltCallFloatingMinimizedView] onActiveUserIDUpdate`, activeUserID);
        setActiveUserID(activeUserID);
      });
    }
    return () => {
      _minimizing_helper.default.getInstance().onWindowMinimized(callbackID);
      _minimizing_helper.default.getInstance().onWindowMaximized(callbackID);
      _minimizing_helper.default.getInstance().onEntryNormal(callbackID);
      _minimizing_helper.default.getInstance().onActiveUserIDUpdate(callbackID);
    };
  }, [isInit]);
  (0, _react.useEffect)(() => {
    _zegoUikitRn.default.onOnlySelfInRoom(callbackID, () => {
      (0, _logger.zloginfo)('[ZegoUIKitPrebuiltCallFloatingMinimizedView][onOnlySelfInRoom] callbackID:', callbackID);
      const isMinimize = _minimizing_helper.default.getInstance().getIsMinimize();
      let routeParams = _prebuilt_helper.default.getInstance().getRouteParams();
      const duration = _timing_helper.default.getInstance().getDuration();
      if (isMinimize && typeof routeParams.onCallEnd == 'function') {
        (0, _logger.zloginfo)('[ZegoUIKitPrebuiltCallFloatingMinimizedView][onOnlySelfInRoom] notify requireConfig.onCallEnd will');
        routeParams.onCallEnd(routeParams.roomID, _defines.ZegoCallEndReason.remoteHangUp, duration);
        (0, _logger.zloginfo)('[ZegoUIKitPrebuiltCallFloatingMinimizedView][onOnlySelfInRoom] notify requireConfig.onCallEnd succeed');
        _prebuilt_helper.default.getInstance().notifyDestroyPrebuilt();
      }
    });
    _zegoUikitRn.default.onMeRemovedFromRoom(callbackID, () => {
      (0, _logger.zloginfo)('[ZegoUIKitPrebuiltCallFloatingMinimizedView][onMeRemovedFromRoom] callbackID:', callbackID);
      const isMinimize = _minimizing_helper.default.getInstance().getIsMinimize();
      let routeParams = _prebuilt_helper.default.getInstance().getRouteParams();
      const duration = _timing_helper.default.getInstance().getDuration();
      if (isMinimize && typeof routeParams.onCallEnd == 'function') {
        (0, _logger.zloginfo)('[ZegoUIKitPrebuiltCallFloatingMinimizedView][onMeRemovedFromRoom] notify requireConfig.onCallEnd will');
        routeParams.onCallEnd(routeParams.roomID, _defines.ZegoCallEndReason.kickOut, duration);
        (0, _logger.zloginfo)('[ZegoUIKitPrebuiltCallFloatingMinimizedView][onMeRemovedFromRoom] notify requireConfig.onCallEnd succeed');
        _prebuilt_helper.default.getInstance().notifyDestroyPrebuilt();
      }
    });
    return () => {
      // It will never be executed because this view is persistent.
      _zegoUikitRn.default.onOnlySelfInRoom(callbackID);
      _zegoUikitRn.default.onMeRemovedFromRoom(callbackID);
    };
  }, []);
  return /*#__PURE__*/_react.default.createElement(_reactNative.Animated.View, _extends({
    style: [{
      position: 'absolute',
      left: layout.left,
      top: layout.top
    }, {
      display: isVisable ? 'flex' : 'none'
    }],
    onLayout: layoutHandle
  }, panResponder.panHandlers), /*#__PURE__*/_react.default.createElement(_reactNative.View, {
    style: [styles.floatAudioView, {
      width,
      height,
      borderRadius
    }]
  }, activeUserID ? /*#__PURE__*/_react.default.createElement(_zegoUikitRn.ZegoAudioVideoView, {
    key: activeUserID,
    userID: activeUserID,
    useVideoViewAspectFill: useVideoViewAspectFill,
    showSoundWave: showSoundWaveInAudioMode
  }) : /*#__PURE__*/_react.default.createElement(_reactNative.View, null)));
}
const styles = _reactNative.StyleSheet.create({
  floatAudioView: {
    overflow: 'hidden',
    zIndex: 10000,
    shadowColor: "#000",
    shadowOffset: {
      width: 0,
      height: 2
    },
    shadowOpacity: 0.25,
    shadowRadius: 3.84,
    elevation: 8
  }
});
//# sourceMappingURL=ZegoUIKitPrebuiltCallFloatingMinimizedView.js.map