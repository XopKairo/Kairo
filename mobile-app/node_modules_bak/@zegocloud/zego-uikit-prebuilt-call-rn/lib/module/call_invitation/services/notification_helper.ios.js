var _NotificationHelper;
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
import { AppState } from 'react-native';
// @ts-ignore
import { setCategory } from 'react-native-sound';
import uuid from 'react-native-uuid';
import ZegoUIKit from '@zegocloud/zego-uikit-rn';
import ZegoUIKitPrebuiltCallService from '../../services';
import { zlogerror, zloginfo } from '../../utils/logger';
import PrebuiltCallReport from '../../utils/report';
import CallInviteHelper from './call_invite_helper';
import { ZegoInvitationType } from './defines';
import InnerTextHelper from './inner_text_helper';
import ZegoPrebuiltPlugins from './plugins';
export default class NotificationHelper {
  constructor() {
    _defineProperty(this, "TAG", 'NotificationHelper');
    _defineProperty(this, "_signalingPlugin", ZegoUIKit.getSignalingPlugin());
    _defineProperty(this, "_uikitSignalingPlugin", ZegoUIKit.getSignalingPlugin().getZegoUIKitSignalingPlugin().getInstance());
    _defineProperty(this, "_callbackID", `${this.TAG}_${String(Math.floor(Math.random() * 10000))}`);
    _defineProperty(this, "_callData", {});
    _defineProperty(this, "_callIDUuidMap", new Map());
    _defineProperty(this, "_currentCallID", '');
    _defineProperty(this, "_currentCallStatus", 'waiting');
    AppState.addEventListener('change', async nextState => {
      zloginfo('nextState', nextState);
      if (nextState === 'active') {
        this.dismissNotification(this._currentCallID, 'active', this.TAG);
      }
    });
  }
  static getInstance() {
    return this._instance || (this._instance = new NotificationHelper());
  }
  init() {
    zloginfo(`[NotificationHelper][init]`);
    this._uikitSignalingPlugin.onCallKitEndCall(this._onCallKitEndCall.bind(this));
    zloginfo(`[NotificationHelper][init] set onCallKitEndCall`);
    this._uikitSignalingPlugin.onCallKitAnswerCall(this._onCallKitAnswerCall.bind(this));
    zloginfo(`[NotificationHelper][init] set onCallKitAnswerCall`);
  }

  // for offline call
  showOfflineNotification(callID, callUUID, callData) {
    if (!callData) {
      zlogerror('[NotificationHelper][showOfflineNotification] callData is empty');
      return;
    }
    zloginfo(`[NotificationHelper][showOfflineNotification] callID: ${callID}, callUUID: ${callUUID}, callData: ${JSON.stringify(callData)}`);
    let notifyUuid = this._callIDUuidMap.get(callID);
    if (notifyUuid) {
      zloginfo(`[NotificationHelper][showOfflineNotification] callID: ${callID} ignore, already shown notification`);
      this._uikitSignalingPlugin.reportCallKitCallEnded(callUUID, 2); // 2 - RemoteEnded
      return;
    }
    this._callIDUuidMap.set(callID, callUUID);
    let {
      call_id: roomID,
      type,
      inviter,
      invitees
    } = callData;
    if (this._currentCallID && this._currentCallStatus === 'notification') {
      zloginfo(`[NotificationHelper][showOfflineNotification] another call is showing`);
      this._refuse(undefined, callID, roomID, inviter, 'busy', 'restarted');
      this._uikitSignalingPlugin.reportCallKitCallEnded(callUUID, 2); // 2 - RemoteEnded

      PrebuiltCallReport.reportEvent('call/respondInvitation', {
        'call_id': callID,
        'app_state': 'restarted',
        'action': 'busy'
      });
      return;
    }
    this._currentCallID = callID;
    this._currentCallStatus = 'notification';
    zloginfo(`[NotificationHelper][showOfflineNotification] set _currentCallID: ${this._currentCallID}, status: ${this._currentCallStatus}`);
    zloginfo(`[NotificationHelper][showOfflineNotification] displayIncomingCall callID: ${callID}`);

    // callID mean zim callID
    this._callData = {
      callID,
      roomID,
      type,
      inviter,
      invitees,
      isPureOfflinePush: true
    };
    zloginfo(`[NotificationHelper][showOfflineNotification] _callData: ${JSON.stringify(this._callData)}`);
  }

  // for online call when background
  showOnlineNotification(callID, callData) {
    let notifyUuid = this._callIDUuidMap.get(callID);
    if (notifyUuid) {
      zloginfo(`[NotificationHelper][showOnlineNotification] callID: ${callID} ignore, already shown notification`);
      return;
    }
    if (!callData) {
      zlogerror('[NotificationHelper][showOnlineNotification] _callData is empty');
      return;
    }

    // @ts-ignore
    let {
      roomID,
      type,
      inviter,
      invitees
    } = callData;
    zloginfo(`[NotificationHelper][showOnlineNotification] callID: ${callID}, roomID: ${roomID}, isVideoCall: ${type}, inviter: ${JSON.stringify(inviter)}, invitees: ${JSON.stringify(invitees)}`);
    notifyUuid = uuid.v4();
    zloginfo(`[NotificationHelper][showOnlineNotification] reportIncomingCall callID: ${callID}, uuid: ${notifyUuid}`);
    const callerName = InnerTextHelper.instance().getIncomingCallDialogTitle(inviter.name, type, invitees.length);
    zloginfo(`[NotificationHelper][showOnlineNotification], callerName: ${callerName}`);
    let cxCallUpdate = {};
    cxCallUpdate.localizedCallerName = callerName;
    cxCallUpdate.hasVideo = type === ZegoInvitationType.videoCall;
    this._uikitSignalingPlugin.reportIncomingCall(cxCallUpdate, notifyUuid).then(() => {
      zloginfo(`[NotificationHelper][showOnlineNotification] reportIncomingCall succeeded, callID: ${callID}`);
    }).catch(message => {
      zlogerror(`[NotificationHelper][showOnlineNotification] reportIncomingCall failed, reason: ${message}`);
    });
    this._currentCallID = callID;
    this._currentCallStatus = 'notification';
    zloginfo(`[NotificationHelper][showOnlineNotification] set _currentCallID: ${this._currentCallID}, status: ${this._currentCallStatus}`);
    this._callIDUuidMap.set(callID, notifyUuid);
    zloginfo(`[NotificationHelper][showOnlineNotification] set ${callID} into _callIDUuidMap`);
    PrebuiltCallReport.reportEvent('call/displayNotification', {
      'call_id': callID,
      'app_state': AppState.currentState
    });
    this._callData = {
      callID,
      roomID,
      type,
      inviter,
      invitees
    };
    zloginfo(`[NotificationHelper][showOnlineNotification] _callData: ${JSON.stringify(this._callData)}`);
  }
  dismissNotification(callID, reason, from) {
    zloginfo(`[NotificationHelper][dismissNotification] callID: ${callID}, reason: ${reason}, from: ${from}`);
    if (reason === 'active') {
      // Handed over to the active state for handling
      let notifyUuid = this._callIDUuidMap.get(callID);
      if (notifyUuid) {
        this._uikitSignalingPlugin.reportCallKitCallEnded(notifyUuid, 2); // 2 - RemoteEnded
        this._currentCallID = '';
        this._currentCallStatus = 'waiting';
        zloginfo(`[NotificationHelper][dismissNotification] set _currentCallID: ${this._currentCallID}, status: ${this._currentCallStatus}`);
      }
    } else if (reason === 'BeCancelled' || reason === 'Timeout') {
      if (!callID || callID !== this._currentCallID) {
        zloginfo(`[NotificationHelper][dismissNotification] ignore callID: ${callID}`);
        return;
      }
      let notifyUuid = this._callIDUuidMap.get(callID);
      if (notifyUuid) {
        this._uikitSignalingPlugin.reportCallKitCallEnded(notifyUuid, 2); // 2 - RemoteEnded
        this._currentCallID = '';
        this._currentCallStatus = 'waiting';
        zloginfo(`[NotificationHelper][dismissNotification] set _currentCallID: ${this._currentCallID}, status: ${this._currentCallStatus}`);
        PrebuiltCallReport.reportEvent('call/respondInvitation', {
          'call_id': callID,
          'app_state': AppState.currentState,
          'action': reason
        });
      }
    }
  }
  _onCallKitEndCall(action) {
    if (!this._callData) {
      zlogerror('[NotificationHelper][_onCallKitEndCall] _callData is empty');
      return;
    }
    zloginfo(`[NotificationHelper][_onCallKitEndCall] callData: ${JSON.stringify(this._callData)}, state: ${AppState.currentState}`);

    // Offline incoming calls are not supported (too early), and online incoming calls rely on ZegoCallInvitationDialog
    // CallEventNotifyApp.getInstance().notifyIncomingCallDeclineButtonPressed()

    if (this._currentCallID && this._currentCallStatus === 'calling') {
      // click accept and hangup
      this.hangUp(this._currentCallID, 'onCallKitEndCall');
      zloginfo(`[NotificationHelper][_onCallKitEndCall] hangUp`);
      this._currentCallID = '';
      this._currentCallStatus = 'waiting';
      zloginfo(`[NotificationHelper][_onCallKitEndCall] set _currentCallID: ${this._currentCallID}, status: ${this._currentCallStatus}`);
      action.fulfill();
    } else {
      // click decline button from notification

      // @ts-ignore
      let {
        callID,
        roomID,
        inviter
      } = this._callData;
      this._callData = undefined;
      zloginfo(`[NotificationHelper][_onCallKitEndCall] will refuse after signalingPlugin login succ, callbackID: ${this._callbackID}`);
      this._refuse(action, callID, roomID, inviter, 'refuse', AppState.currentState);
    }
  }
  _refuse(action, callID, roomID, inviter, reason, appState) {
    this._signalingPlugin.onLoginSuccess(this._callbackID, () => {
      // tell caller
      this._signalingPlugin.refuseInvitation(inviter.id, JSON.stringify({
        callID,
        call_id: roomID,
        // @ts-ignore
        'invitee': {
          userID: ZegoPrebuiltPlugins.getLocalUser().userID,
          userName: ZegoPrebuiltPlugins.getLocalUser().userName
        }
      })).then(result => {
        zloginfo(`[NotificationHelper][_onCallKitEndCall] refuseInvitation then, code: ${result.code}, message: ${result.message}`);
        PrebuiltCallReport.reportEvent('call/respondInvitation', {
          'call_id': callID,
          'app_state': appState,
          'action': reason
        });
        CallInviteHelper.getInstance().refuseCall(callID);
        this._currentCallID = '';
        this._currentCallStatus = 'waiting';
        zloginfo(`[NotificationHelper][_onCallKitEndCall] set _currentCallID: ${this._currentCallID}, status: ${this._currentCallStatus}`);

        // tell ios decline completion
        if (action) {
          action.fulfill();
        }
      }).catch(error => {
        zloginfo(`[NotificationHelper][_onCallKitEndCall] refuseInvitation catch, error: ${error.code}, message: ${error.message}`);
        CallInviteHelper.getInstance().refuseCall(callID);
        this._currentCallID = '';
        this._currentCallStatus = 'waiting';
        zloginfo(`[NotificationHelper][_onCallKitEndCall] set _currentCallID: ${this._currentCallID}, status: ${this._currentCallStatus}`);

        // tell ios decline fail
        if (action) {
          action.fail();
        }
      });
      this._signalingPlugin.onLoginSuccess(this._callbackID);
    });
  }
  _onCallKitAnswerCall(action) {
    if (!this._callData) {
      zlogerror('[NotificationHelper][_onCallKitAnswerCall] _callData is empty');
      return;
    }
    zloginfo(`[NotificationHelper][_onCallKitAnswerCall] callData: ${JSON.stringify(this._callData)}, state: ${AppState.currentState}`);

    // @ts-ignore
    let {
      callID,
      roomID,
      type,
      inviter,
      invitees,
      isPureOfflinePush
    } = this._callData;
    // this._callData = undefined   // Do not clear it, as it will still be needed when the VoIP call is hangup later.

    zloginfo(`[NotificationHelper][_onCallKitAnswerCall] will accept after signalingPlugin login succ, callbackID: ${this._callbackID}`);
    this._signalingPlugin.onLoginSuccess(this._callbackID, () => {
      let app_state = AppState.currentState;
      if (isPureOfflinePush) {
        CallInviteHelper.getInstance().setOfflineData({
          call_id: roomID,
          type,
          inviter,
          invitees
        });
        app_state = "restarted";
      }
      setCategory('PlayAndRecord');
      CallInviteHelper.getInstance().acceptCall(callID, {
        call_id: roomID,
        type,
        inviter,
        invitees
      });
      ZegoUIKit.getSignalingPlugin().acceptInvitation(inviter.id, JSON.stringify({
        callID,
        call_id: roomID,
        // @ts-ignore
        'invitee': {
          userID: ZegoPrebuiltPlugins.getLocalUser().userID,
          userName: ZegoPrebuiltPlugins.getLocalUser().userName
        }
      })).then(result => {
        zloginfo(`[NotificationHelper][_onCallKitAnswerCall] acceptInvitation then, code: ${result.code}, message: ${result.message}`);
        PrebuiltCallReport.reportEvent('call/respondInvitation', {
          'call_id': callID,
          app_state,
          'action': 'accept'
        });
        this._currentCallID = '';
        this._currentCallStatus = 'waiting';
        zloginfo(`[NotificationHelper][_onCallKitAnswerCall] set _currentCallID: ${this._currentCallID}, status: ${this._currentCallStatus}`);
        if (AppState.currentState === 'background') {
          this._currentCallID = callID;
          this._currentCallStatus = 'calling';
          zloginfo(`[NotificationHelper][_onCallKitAnswerCall] set _currentCallID: ${this._currentCallID}, status: ${this._currentCallStatus}`);
        }
        action.fulfill();
      }).catch(error => {
        zloginfo(`[NotificationHelper][_onCallKitAnswerCall] acceptInvitation catch, error: ${error.code}, message: ${error.message}`);
        this.hangUp(callID, 'acceptFailed');
        CallInviteHelper.getInstance().refuseCall(callID);
        this._currentCallID = '';
        this._currentCallStatus = 'waiting';
        zloginfo(`[NotificationHelper][_onCallKitAnswerCall] set _currentCallID: ${this._currentCallID}, status: ${this._currentCallStatus}`);

        // tell ios decline fail
        action.fail();
      });
    });
  }
  hangUp(callID, reason) {
    zloginfo(`[NotificationHelper][hangUp] callID: ${callID}, reason: ${reason}`);
    if (reason === 'onCallKitEndCall' || reason === 'acceptFailed') {
      ZegoUIKitPrebuiltCallService.getInstance().hangUp();
    } else {
      let notifyUuid = this._callIDUuidMap.get(callID);
      if (notifyUuid) {
        this._uikitSignalingPlugin.reportCallKitCallEnded(notifyUuid, 2); // 2 - RemoteEnded
        this._currentCallID = '';
        this._currentCallStatus = 'waiting';
        zloginfo(`[NotificationHelper][hangUp] set _currentCallID: ${this._currentCallID}, status: ${this._currentCallStatus}`);
      }
    }
  }
  getCurrentInCallID() {
    if (this._currentCallStatus === 'calling') {
      return this._currentCallID;
    } else {
      return '';
    }
  }
}
_NotificationHelper = NotificationHelper;
_defineProperty(NotificationHelper, "_instance", void 0);
//# sourceMappingURL=notification_helper.ios.js.map