"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _zegoExpressEngineReactnative = _interopRequireWildcard(require("zego-express-engine-reactnative"));
var _defines = require("./defines");
var _invitation = _interopRequireDefault(require("../../plugins/invitation"));
var _enum_name = require("../../utils/enum_name");
var _logger = require("../../utils/logger");
var _package_version = require("../../utils/package_version");
var _report = _interopRequireDefault(require("../../utils/report"));
var _version = require("../../utils/version");
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
var _appInfo = {
  appID: 0,
  appSign: ''
};
var _isRoomConnected = false;
var _currentRoomState = 7; // Logout
var _currentRoomID = '';
var _audioOutputType = 0;
var _usingFrontFacingCamera = true;
var _onMicDeviceOnCallbackMap = {};
var _onCameraDeviceOnCallbackMap = {};
var _onRoomStateChangedCallbackMap = {};
var _onRequireNewTokenCallbackMap = {};
var _onUserJoinCallbackMap = {};
var _onUserLeaveCallbackMap = {};
var _onUserInfoUpdateCallbackMap = {};
var _onSoundLevelUpdateCallbackMap = {};
var _onSDKConnectedCallbackMap = {};
var _onAudioOutputDeviceTypeChangeCallbackMap = {};
var _onOnlySelfInRoomCallbackMap = {};
var _onUserCountOrPropertyChangedCallbackMap = {};
var _onAudioVideoAvailableCallbackMap = {};
var _onAudioVideoUnavailableCallbackMap = {};
var _onInRoomMessageReceivedCallbackMap = {};
var _onInRoomMessageSentCallbackMap = {};
var _onRoomPropertyUpdatedCallbackMap = {};
var _onRoomPropertiesFullUpdatedCallbackMap = {};
var _onInRoomCommandReceivedCallbackMap = {};
var _onMeRemovedFromRoomCallbackMap = {};
var _onJoinRoomCallbackMap = {};
var _onTurnOnYourCameraRequestCallbackMap = {};
var _onTurnOnYourMicrophoneRequestCallbackMap = {};
var _onScreenSharingAvailableCallbackMap = {};
var _onScreenSharingUnavailableCallbackMap = {};

// Force update component callback
var _onMemberListForceSortCallbackMap = {};
var _onAudioVideoListForceSortCallbackMap = {};
var _onVideoViewForceRenderCallbackMap = {};
var _localCoreUser = _createCoreUser('', '', '', {});
var _streamCoreUserMap = {}; // <streamID, CoreUser>
var _coreUserMap = {}; // <userID, CoreUser>
var _qualityUpdateLogCounter = 0;
var _inRoomMessageList = [];
var _audioVideoResourceMode = _defines.ZegoAudioVideoResourceMode.Default;
var _roomProperties = {};
var _isLargeRoom = false;
var _roomMemberCount = 0;
var _markAsLargeRoom = false;
var _onErrorCallbackMap = {};
var _onTokenProvideCallback = undefined;
var _videoConfig = _defines.ZegoUIKitVideoConfig.preset360P();
var _appOrientation = _zegoExpressEngineReactnative.ZegoOrientation.PortraitUp;
var _engineState = _zegoExpressEngineReactnative.ZegoEngineState.Stop;
const _screenshareStreamIDFlag = '_screensharing';
function _resetData() {
  (0, _logger.zloginfo)('Reset all data.');
  _appInfo = {
    appID: 0,
    appSign: ''
  };
  _localCoreUser = _createCoreUser('', '', '', {});
  _localCoreUser.isLandscape = _appOrientation !== 0;
  _streamCoreUserMap = {};
  _coreUserMap = {};
  _currentRoomID = '';
  _currentRoomState = 7;
  _isRoomConnected = false;
  _audioOutputType = 0;
  _inRoomMessageList = [];
  _audioVideoResourceMode = _defines.ZegoAudioVideoResourceMode.Default;
  _isLargeRoom = false;
  _roomMemberCount = 0;
  _markAsLargeRoom = false;
}
function _resetDataForLeavingRoom() {
  (0, _logger.zloginfo)('Reset data for leaving room.');
  _streamCoreUserMap = {};
  _coreUserMap = {};
  _currentRoomID = '';
  _currentRoomState = 7;
  _isRoomConnected = false;
  const {
    userID,
    userName,
    profileUrl,
    extendInfo
  } = _localCoreUser;
  _localCoreUser = _createCoreUser(userID, userName, profileUrl, extendInfo);
  _localCoreUser.isLandscape = _appOrientation !== 0;
  _coreUserMap[_localCoreUser.userID] = _localCoreUser;
  _inRoomMessageList = [];
  _roomProperties = {};
  _isLargeRoom = false;
  _roomMemberCount = 0;
  _markAsLargeRoom = false;
}
function _createPublicUser(coreUser) {
  return {
    userID: coreUser.userID,
    userName: coreUser.userName,
    extendInfo: coreUser.extendInfo,
    isMicrophoneOn: coreUser.isMicDeviceOn,
    isCameraOn: coreUser.isCameraDeviceOn,
    soundLevel: coreUser.soundLevel,
    inRoomAttributes: coreUser.inRoomAttributes,
    avatar: coreUser.avatar
  };
}
function _createCoreUser(userID, userName, profileUrl, extendInfo) {
  return {
    userID: userID,
    userName: userName,
    profileUrl: profileUrl,
    extendInfo: extendInfo,
    viewID: -1,
    viewFillMode: 1,
    streamID: '',
    screenshareViewID: -1,
    screenshareViewFillMode: 1,
    screenshareStreamID: '',
    isMicDeviceOn: false,
    isCameraDeviceOn: false,
    publisherQuality: 0,
    soundLevel: 0,
    joinTime: 0,
    inRoomAttributes: {},
    avatar: '',
    isLandscape: false
  };
}
function _isLocalUser(userID) {
  return userID === undefined || userID === '' || _localCoreUser.userID === userID;
}
function _setLocalUserInfo(userInfo) {
  _localCoreUser = _createCoreUser(userInfo.userID, userInfo.userName, userInfo.profileUrl, userInfo.extendInfo);
  _coreUserMap[userInfo.userID] = _localCoreUser;
}
function _onRoomUserUpdate(roomID, updateType, userList) {
  // No need for roomID, does not support multi-room right now.
  const userInfoList = [];
  if (updateType == _zegoExpressEngineReactnative.ZegoUpdateType.Add) {
    _roomMemberCount += userList.length;
    if (_roomMemberCount >= 500) {
      _isLargeRoom = true;
    }
    userList.forEach(user => {
      if (!(user.userID in _coreUserMap)) {
        const coreUser = _createCoreUser(user.userID, user.userName);
        _coreUserMap[user.userID] = coreUser;
      }
      const streamID = _getStreamIDByUserID(user.userID);
      if (streamID in _streamCoreUserMap) {
        _coreUserMap[user.userID].streamID = streamID;
      }
      const screenshareStreamID = _getScreenshareStreamIDByUserID(user.userID);
      if (screenshareStreamID in _streamCoreUserMap) {
        _coreUserMap[user.userID].screenshareStreamID = screenshareStreamID;
      }
      _coreUserMap[user.userID].joinTime = Date.now();
      _notifyUserInfoUpdate(_coreUserMap[user.userID]);
      userInfoList.push(_createPublicUser(_coreUserMap[user.userID]));

      // Start after user insert into list
      _tryStartPlayStream(user.userID);
    });
    _notifyUserCountOrPropertyChanged(_defines.ZegoChangedCountOrProperty.userAdd);
    (0, _logger.zloginfo)('Users Join: ', userInfoList);
    Object.keys(_onUserJoinCallbackMap).forEach(callbackID => {
      if (_onUserJoinCallbackMap[callbackID]) {
        _onUserJoinCallbackMap[callbackID](userInfoList);
      }
    });
  } else {
    // updateType == ZegoUpdateType.Delete
    _roomMemberCount -= userList.length;
    userList.forEach(user => {
      if (user.userID in _coreUserMap) {
        const coreUser = _coreUserMap[user.userID];
        const userInfo = {
          userID: coreUser.userID,
          userName: coreUser.userName,
          profileUrl: coreUser.profileUrl,
          extendInfo: coreUser.extendInfo
        };
        userInfoList.push(userInfo);

        // Stop play stream before remove user list
        _tryStopPlayStream(coreUser.userID, true);
        _tryStopPlayScreenshareStream(coreUser.userID);
        delete _coreUserMap[user.userID];
      }
    });
    (0, _logger.zloginfo)('Users Leave: ', userInfoList);
    _notifyUserCountOrPropertyChanged(_defines.ZegoChangedCountOrProperty.userDelete);
    Object.keys(_onUserLeaveCallbackMap).forEach(callbackID => {
      if (_onUserLeaveCallbackMap[callbackID]) {
        _onUserLeaveCallbackMap[callbackID](userInfoList);
      }
    });
    if (Object.keys(_coreUserMap).length <= 1) {
      Object.keys(_onOnlySelfInRoomCallbackMap).forEach(callbackID => {
        if (_onOnlySelfInRoomCallbackMap[callbackID]) {
          _onOnlySelfInRoomCallbackMap[callbackID]();
        }
      });
    }
  }
}
function _onRoomStreamUpdate(roomID, updateType, streamList) {
  (0, _logger.zloginfo)('_onRoomStreamUpdate: ', roomID, updateType, streamList);
  var users = [];
  var screenshareUsers = [];
  if (updateType == 0) {
    // Add
    streamList.forEach(stream => {
      const userID = stream.user.userID;
      const userName = stream.user.userName;
      const streamID = stream.streamID;
      const isScreenSharing = streamID.endsWith(_screenshareStreamIDFlag);
      if (userID in _coreUserMap) {
        if (isScreenSharing) {
          _coreUserMap[userID].screenshareStreamID = streamID;
        } else {
          _coreUserMap[userID].streamID = streamID;
        }
        _streamCoreUserMap[streamID] = _coreUserMap[userID];
        _notifyUserInfoUpdate(_coreUserMap[userID]);
        _tryStartPlayStream(userID);
      } else {
        const coreUser = _createCoreUser(userID, userName, '', {});
        if (isScreenSharing) {
          coreUser.screenshareStreamID = streamID;
        } else {
          coreUser.streamID = streamID;
        }
        _streamCoreUserMap[streamID] = coreUser;
        _coreUserMap[userID] = coreUser;
      }

      // Add users.
      users.push(_coreUserMap[userID]);
      if (isScreenSharing) {
        screenshareUsers.push(_coreUserMap[userID]);
      }
      parseStreamExtraInfo(stream);
    });

    // notify
    _notifyAudioVideoAvailable(users);
    _notifyScreenSharingAvailable(screenshareUsers);
  } else {
    streamList.forEach(stream => {
      const userID = stream.user.userID;
      const streamID = stream.streamID;
      const isScreenSharing = streamID.endsWith(_screenshareStreamIDFlag);
      if (userID in _coreUserMap) {
        if (isScreenSharing) {
          _tryStopPlayScreenshareStream(userID);
          _coreUserMap[userID].screenshareStreamID = '';
        } else {
          _tryStopPlayStream(userID, true);
          _coreUserMap[userID].isCameraDeviceOn = false;
          _coreUserMap[userID].isMicDeviceOn = false;
          _coreUserMap[userID].streamID = '';
          _notifyUserInfoUpdate(_coreUserMap[userID]);
        }

        // Add users.
        users.push(_coreUserMap[userID]);
        if (isScreenSharing) {
          screenshareUsers.push(_coreUserMap[userID]);
        }
        delete _streamCoreUserMap[streamID];
      }
    });

    // notify.
    _notifyUserCountOrPropertyChanged(_defines.ZegoChangedCountOrProperty.cameraStateUpdate);
    _notifyAudioVideoUnavailable(users);
    _notifyScreenSharingUnavailable(screenshareUsers);
  }
}
function _onRemoteCameraStateUpdate(userID, isOn) {
  if (userID in _coreUserMap) {
    _coreUserMap[userID].isCameraDeviceOn = isOn;
    (0, _logger.zloginfo)(`RemoteCameraStateUpdate, ${userID} camera: ${isOn}`);
    _notifyUserInfoUpdate(_coreUserMap[userID]);
    _notifyUserCountOrPropertyChanged(_defines.ZegoChangedCountOrProperty.cameraStateUpdate);
    Object.keys(_onCameraDeviceOnCallbackMap).forEach(callbackID => {
      if (_onCameraDeviceOnCallbackMap[callbackID]) {
        _onCameraDeviceOnCallbackMap[callbackID](userID, isOn);
      }
    });
    if (userID != _localCoreUser.userID) {
      if (isOn) {
        _tryStartPlayStream(userID);
      }
    }
  }
}
function _onAudioRouteChange(type) {
  Object.keys(_onAudioOutputDeviceTypeChangeCallbackMap).forEach(callbackID => {
    if (_onAudioOutputDeviceTypeChangeCallbackMap[callbackID]) {
      _onAudioOutputDeviceTypeChangeCallbackMap[callbackID](type);
    }
  });
  _audioOutputType = type;
}
function _onRemoteMicStateUpdate(userID, isOn) {
  if (userID in _coreUserMap) {
    _coreUserMap[userID].isMicDeviceOn = isOn;
    _notifyUserInfoUpdate(_coreUserMap[userID]);
    _notifyUserCountOrPropertyChanged(_defines.ZegoChangedCountOrProperty.microphoneStateUpdate);
    Object.keys(_onMicDeviceOnCallbackMap).forEach(callbackID => {
      if (_onMicDeviceOnCallbackMap[callbackID]) {
        _onMicDeviceOnCallbackMap[callbackID](userID, isOn);
      }
    });
    if (userID != _localCoreUser.userID) {
      if (isOn) {
        _tryStartPlayStream(userID);
      }
    }
  }
}
function _onRoomStateChanged(roomID, reason, errorCode, extendedData) {
  (0, _logger.zloginfo)(`Room state changed: roomID: ${roomID}, reason: ${reason}, error: ${errorCode}, extendedData: ${extendedData}`);

  // Not support multi-room right now
  if (reason == _zegoExpressEngineReactnative.ZegoRoomStateChangedReason.Logined || reason == _zegoExpressEngineReactnative.ZegoRoomStateChangedReason.Reconnected) {
    // Logined || Reconnected
    _isRoomConnected = true;
    _tryStartPublishStream();
  } else {
    _isRoomConnected = false;
    if (reason === _zegoExpressEngineReactnative.ZegoRoomStateChangedReason.KickOut) {
      // KickOut
      _notifyMeRemovedFromRoom();
    }
  }
  _currentRoomState = reason;
  Object.keys(_onRoomStateChangedCallbackMap).forEach(callbackID => {
    // callback may remove from map during room state chaging
    if (callbackID in _onRoomStateChangedCallbackMap) {
      if (_onRoomStateChangedCallbackMap[callbackID]) {
        _onRoomStateChangedCallbackMap[callbackID](reason, errorCode, extendedData);
      }
    }
  });
}
function _onInRoomMessageReceived(roomID, messageList) {
  (0, _logger.zloginfo)('Received in room message: ', roomID, messageList.length);
  var messages = [];
  messageList.forEach(msg => {
    const message = {
      type: 'user',
      message: msg.message,
      messageID: msg.messageID,
      sendTime: msg.sendTime,
      sender: _createPublicUser(_coreUserMap[msg.fromUser.userID])
    };
    messages.push(message);
    _inRoomMessageList.push(message);
  });
  Object.keys(_onInRoomMessageReceivedCallbackMap).forEach(callbackID => {
    // callback may remove from map during room state chaging
    if (callbackID in _onInRoomMessageReceivedCallbackMap) {
      if (_onInRoomMessageReceivedCallbackMap[callbackID]) {
        _onInRoomMessageReceivedCallbackMap[callbackID](messages);
      }
    }
  });
}
async function _onRequireNewToken() {
  Object.keys(_onRequireNewTokenCallbackMap).forEach(callbackID => {
    if (callbackID in _onRequireNewTokenCallbackMap) {
      if (_onRequireNewTokenCallbackMap[callbackID]) {
        const token = _onRequireNewTokenCallbackMap[callbackID]();
        if (token) {
          _zegoExpressEngineReactnative.default.instance().renewToken(_currentRoomID, token).then(() => {
            (0, _logger.zloginfo)('Renew token success');
          }).catch(error => {
            (0, _logger.zlogerror)('Renew token failed: ', error);
          });
        } else {
          (0, _logger.zlogerror)('Renew token failed: the returned token is abnormal');
        }
      }
    }
  });
  const token = await ZegoUIKitInternal.getToken();
  if (token) {
    _zegoExpressEngineReactnative.default.instance().renewToken(_currentRoomID, token).then(() => {
      (0, _logger.zloginfo)('Renew token success');
    }).catch(error => {
      (0, _logger.zlogerror)('Renew token failed: ', error);
    });
  }
}
function _onRoomExtraInfoUpdate(roomID, roomExtraInfoList) {
  (0, _logger.zloginfo)(`[ZegoUIKitInternal] _onRoomExtraInfoUpdate, roomID:${roomID}, roomExtraInfo:${roomExtraInfoList}`);
  const updateKeys = [];
  const oldRoomProperties = JSON.parse(JSON.stringify(_roomProperties));
  roomExtraInfoList.forEach(({
    key,
    updateTime,
    updateUser,
    value
  }) => {
    if (key === 'extra_info') {
      const roomProperties = JSON.parse(value);
      Object.keys(roomProperties).forEach(propertyKey => {
        if (oldRoomProperties[propertyKey] !== roomProperties[propertyKey]) {
          updateKeys.push(propertyKey);
          _roomProperties[propertyKey] = roomProperties[propertyKey];
          _notifyRoomPropertyUpdate(propertyKey, oldRoomProperties[propertyKey], roomProperties[propertyKey], _defines.ZegoRoomPropertyUpdateType.remote);
        }
      });
    }
  });
  if (updateKeys.length > 0) {
    _notifyRoomPropertiesFullUpdate(updateKeys, oldRoomProperties, JSON.parse(JSON.stringify(_roomProperties)), _defines.ZegoRoomPropertyUpdateType.remote);
  }
}
function _onIMCustomCommandReceived(roomID, fromUser, command) {
  (0, _logger.zloginfo)(`[ZegoUIKitInternal] _onIMCustomCommandReceived, roomID: ${roomID}, fromUser: ${fromUser}, command: ${command}`);
  try {
    const commandObj = JSON.parse(command);
    if (commandObj && typeof commandObj === 'object') {
      fromUser = _createPublicUser(_coreUserMap[fromUser.userID] || fromUser);
      const removeUserIDList = commandObj.zego_remove_user;
      const turnCameraOnUserID = commandObj.zego_turn_camera_on;
      const turnCameraOffUserID = commandObj.zego_turn_camera_off;
      const turnMicrophoneOnUserID = commandObj.zego_turn_microphone_on;
      const turnMicrophoneOffUserID = commandObj.zego_turn_microphone_off;
      if (removeUserIDList && removeUserIDList.find(removeUserID => removeUserID === _localCoreUser.userID)) {
        _notifyMeRemovedFromRoom();
        // Leave the room automatically
        _leaveRoom();
      } else if (turnCameraOnUserID === _localCoreUser.userID) {
        Object.keys(_onTurnOnYourCameraRequestCallbackMap).forEach(callbackID => {
          if (_onTurnOnYourCameraRequestCallbackMap[callbackID]) {
            _onTurnOnYourCameraRequestCallbackMap[callbackID](fromUser);
          }
        });
      } else if (turnMicrophoneOnUserID === _localCoreUser.userID) {
        Object.keys(_onTurnOnYourMicrophoneRequestCallbackMap).forEach(callbackID => {
          if (_onTurnOnYourMicrophoneRequestCallbackMap[callbackID]) {
            _onTurnOnYourMicrophoneRequestCallbackMap[callbackID](fromUser);
          }
        });
      } else if (turnCameraOffUserID === _localCoreUser.userID) {
        _turnCameraDeviceOn(_localCoreUser.userID, false);
        // Automatic shutdown
      } else if (turnMicrophoneOffUserID === _localCoreUser.userID) {
        // Automatic shutdown
        _turnMicDeviceOn(_localCoreUser.userID, false);
      }
    }
  } catch (error) {
    (0, _logger.zlogerror)(error);
  }
  (0, _logger.zloginfo)('_onIMCustomCommandReceived: ', roomID, fromUser, command);
  Object.keys(_onInRoomCommandReceivedCallbackMap).forEach(callbackID => {
    if (callbackID in _onInRoomCommandReceivedCallbackMap) {
      if (_onInRoomCommandReceivedCallbackMap[callbackID]) {
        _onInRoomCommandReceivedCallbackMap[callbackID](fromUser, command);
      }
    }
  });
}
function _sendInRoomCommand(command, toUserList) {
  if (!_isRoomConnected) {
    (0, _logger.zlogerror)('You need to join the room before using this interface!');
    return Promise.reject();
  }
  return new Promise((resolve, reject) => {
    _zegoExpressEngineReactnative.default.instance().sendCustomCommand(_currentRoomID, command, toUserList).then(({
      errorCode
    }) => {
      if (errorCode === 0) {
        (0, _logger.zloginfo)('[sendInRoomCommand]Send successfully', toUserList);
        resolve();
      } else {
        (0, _logger.zloginfo)('[sendInRoomCommand]Send failure', toUserList);
        reject();
      }
    }).catch(error => {
      (0, _logger.zloginfo)('[sendInRoomCommand]Send error', error);
      reject();
    });
  });
}
function _leaveRoom() {
  return new Promise((resolve, reject) => {
    if (_currentRoomID == '') {
      (0, _logger.zloginfo)('You are not join in any room, no need to leave room.');
      resolve();
    } else {
      (0, _logger.zloginfo)('userID:', _localCoreUser.userID, ' leaveRoom:', _currentRoomID);
      _zegoExpressEngineReactnative.default.instance().logoutRoom(_currentRoomID).then(() => {
        (0, _logger.zloginfo)('Leave room succeed.');
        _report.default.reportEvent('logoutRoom', {
          'room_id': _currentRoomID,
          'error': 0,
          'msg': ''
        });
        _currentRoomID = '';
        _turnCameraDeviceOn(_localCoreUser.userID, false);
        _turnMicDeviceOn(_localCoreUser.userID, false);
        _zegoExpressEngineReactnative.default.instance().stopSoundLevelMonitor();
        _notifyUserCountOrPropertyChanged(_defines.ZegoChangedCountOrProperty.userDelete);
        _resetDataForLeavingRoom();
        resolve();
      }).catch(error => {
        (0, _logger.zlogerror)('Leave room failed: ', error);
        _report.default.reportEvent('logoutRoom', {
          'room_id': _currentRoomID,
          'error': -1,
          'msg': JSON.stringify(error)
        });
        reject(error);
      });
    }
  });
}
function _turnMicDeviceOn(userID, on) {
  return new Promise((resolve, reject) => {
    if (_isLocalUser(userID)) {
      (0, _logger.zloginfo)(`turnMicDeviceOn: userID: ${_localCoreUser.userID}, mic: ${on}`);
      _zegoExpressEngineReactnative.default.instance().muteMicrophone(!on);
      _onRemoteMicStateUpdate(_localCoreUser.userID, on);
      _localCoreUser.isMicDeviceOn = on;
      _coreUserMap[_localCoreUser.userID].isMicDeviceOn = on;
      _notifyUserInfoUpdate(_localCoreUser);
      _notifyUserCountOrPropertyChanged(_defines.ZegoChangedCountOrProperty.microphoneStateUpdate);

      // sync device status via stream extra info
      var extraInfo = {
        isCameraOn: _localCoreUser.isCameraDeviceOn,
        isMicrophoneOn: on
      };
      _zegoExpressEngineReactnative.default.instance().setStreamExtraInfo(JSON.stringify(extraInfo), _zegoExpressEngineReactnative.ZegoPublishChannel.Main);
      if (on) {
        _tryStartPublishStream();
      } else {
        _tryStopPublishStream(); // Don't worry! It will check internally that both the camera and microphone are turned off before stopping the stream.
      }
      resolve();
    } else {
      const isLargeRoom = _isLargeRoom || _markAsLargeRoom;
      const command = on ? JSON.stringify({
        zego_turn_microphone_on: userID
      }) : JSON.stringify({
        zego_turn_microphone_off: userID
      });
      const userInfo = _coreUserMap[userID];
      const userName = userInfo ? userInfo.userName || '' : '';
      const toUserList = isLargeRoom ? [] : [{
        userID,
        userName
      }];
      _sendInRoomCommand(command, toUserList).then(() => {
        (0, _logger.zloginfo)('turnMicDeviceOn others: ', userID, on);
        resolve();
      }).catch(() => {
        (0, _logger.zlogerror)('turnMicDeviceOn others error: ', userID, on);
        reject();
      });
    }
  });
}
function _turnCameraDeviceOn(userID, on) {
  return new Promise((resolve, reject) => {
    if (_isLocalUser(userID)) {
      // Default to Main Channel
      (0, _logger.zloginfo)('turnCameraDeviceOn: ', _localCoreUser.userID, on);
      _zegoExpressEngineReactnative.default.instance().enableCamera(on, 0);
      _onRemoteCameraStateUpdate(_localCoreUser.userID, on);
      _localCoreUser.isCameraDeviceOn = on;
      // if (!on) {
      //     _localCoreUser.viewID = -1;
      // }
      _coreUserMap[_localCoreUser.userID] = _localCoreUser;
      _notifyUserInfoUpdate(_localCoreUser);
      _notifyUserCountOrPropertyChanged(_defines.ZegoChangedCountOrProperty.cameraStateUpdate);

      // sync device status via stream extra info
      var extraInfo = {
        isCameraOn: on,
        isMicrophoneOn: _localCoreUser.isMicDeviceOn
      };
      _zegoExpressEngineReactnative.default.instance().setStreamExtraInfo(JSON.stringify(extraInfo), _zegoExpressEngineReactnative.ZegoPublishChannel.Main);
      if (on) {
        _tryStartPublishStream();
      } else {
        _tryStopPublishStream(); // Don't worry! It will check internally that both the camera and microphone are turned off before stopping the stream.
      }
      resolve();
    } else {
      const isLargeRoom = _isLargeRoom || _markAsLargeRoom;
      const command = on ? JSON.stringify({
        zego_turn_camera_on: userID
      }) : JSON.stringify({
        zego_turn_camera_off: userID
      });
      const userInfo = _coreUserMap[userID];
      const userName = userInfo ? userInfo.userName || '' : '';
      const toUserList = isLargeRoom ? [] : [{
        userID,
        userName
      }];
      _sendInRoomCommand(command, toUserList).then(() => {
        (0, _logger.zloginfo)('turnCameraDeviceOn others: ', userID, on);
        resolve();
      }).catch(() => {
        (0, _logger.zlogerror)('turnCameraDeviceOn others error: ', userID, on);
        reject();
      });
    }
  });
}
function _registerEngineCallback() {
  (0, _logger.zloginfo)('Register callback for ZegoExpressEngine...');
  _zegoExpressEngineReactnative.default.instance().on('roomUserUpdate', (roomID, updateType, userList) => {
    (0, _logger.zloginfo)('[roomUserUpdate callback]', roomID, (0, _enum_name.getZegoUpdateTypeName)(updateType), userList);
    _onRoomUserUpdate(roomID, updateType, userList);
  });
  _zegoExpressEngineReactnative.default.instance().on('roomStreamUpdate', (roomID, updateType, streamList) => {
    (0, _logger.zloginfo)('[roomStreamUpdate callback]', roomID, (0, _enum_name.getZegoUpdateTypeName)(updateType), streamList);
    _onRoomStreamUpdate(roomID, updateType, streamList);
  });
  _zegoExpressEngineReactnative.default.instance().on('publisherQualityUpdate', (streamID, quality) => {
    if (_qualityUpdateLogCounter % 10 == 0) {
      _qualityUpdateLogCounter = 0;
      (0, _logger.zloginfo)('[publisherQualityUpdate callback]', streamID, quality);
    }
    _qualityUpdateLogCounter++;
    if (streamID.split('_')[2] === 'main') {
      _localCoreUser.publisherQuality = quality;
      _coreUserMap[_localCoreUser.userID].publisherQuality = quality;
      _notifyUserInfoUpdate(_coreUserMap[_localCoreUser.userID]);
    }
  });
  // ZegoExpressEngine.instance().on(
  //     'publisherStateUpdate',
  //     (streamID, state, errorCode, extendedData) => {
  //         zloginfo('publisherStateUpdate#################', streamID, state, errorCode)
  //     },
  // );
  _zegoExpressEngineReactnative.default.instance().on('playerQualityUpdate', (streamID, quality) => {
    if (_qualityUpdateLogCounter % 10 == 0) {
      // zloginfo('[playerQualityUpdate callback]', streamID, quality);
    }
    // TODO
  });
  _zegoExpressEngineReactnative.default.instance().on('remoteCameraStateUpdate', (streamID, state) => {
    (0, _logger.zloginfo)('[remoteCameraStateUpdate callback]', streamID, (0, _enum_name.getZegoRemoteDeviceStateName)(state));
    if (streamID.endsWith(_screenshareStreamIDFlag)) {
      return;
    }
    let isCameraOn = state == _zegoExpressEngineReactnative.ZegoRemoteDeviceState.Open;
    _onRemoteCameraStateUpdate(_getUserIDByStreamID(streamID), isCameraOn);
  });
  _zegoExpressEngineReactnative.default.instance().on('remoteMicStateUpdate', (streamID, state) => {
    (0, _logger.zloginfo)('[remoteMicStateUpdate callback]', streamID, (0, _enum_name.getZegoRemoteDeviceStateName)(state));
    if (streamID.endsWith(_screenshareStreamIDFlag)) {
      return;
    }
    let isMicOn = state == _zegoExpressEngineReactnative.ZegoRemoteDeviceState.Open;
    _onRemoteMicStateUpdate(_getUserIDByStreamID(streamID), isMicOn);
  });
  _zegoExpressEngineReactnative.default.instance().on('playerStateUpdate', (streamID, state, errorCode, extendedData) => {
    (0, _logger.zloginfo)('[playerStateUpdate callback]', streamID, state, errorCode, extendedData);
  });
  _zegoExpressEngineReactnative.default.instance().on('remoteSoundLevelUpdate', soundLevels => {
    // {streamID, soundLavel} value from 0.0 to 100.0
    // zloginfo('[remoteSoundLevelUpdate callback]', soundLevels);
    Object.keys(soundLevels).forEach(streamID => {
      const userID = _getUserIDByStreamID(streamID);
      if (userID in _coreUserMap) {
        _coreUserMap[userID].soundLevel = soundLevels[streamID];
        _notifySoundLevelUpdate(userID, soundLevels[streamID]);
      }
    });
  });
  _zegoExpressEngineReactnative.default.instance().on('capturedSoundLevelUpdate', soundLevel => {
    if (_localCoreUser.userID === '' || !(_localCoreUser.userID in _coreUserMap)) {
      return;
    }
    _localCoreUser.soundLevel = soundLevel;
    _coreUserMap[_localCoreUser.userID].soundLevel = soundLevel;
    _notifySoundLevelUpdate(_localCoreUser.userID, soundLevel);
    // zloginfo('capturedSoundLevelUpdate', soundLevel)
  });
  // https://doc-en-api.zego.im/ReactNative/enums/_zegoexpressdefines_.zegoroomstatechangedreason.html
  _zegoExpressEngineReactnative.default.instance().on('roomStateChanged', (roomID, reason, errorCode, extendedData) => {
    (0, _logger.zloginfo)('[roomStateChanged callback]', roomID, reason, errorCode, extendedData);
    _onRoomStateChanged(roomID, reason, errorCode, extendedData);
  });
  _zegoExpressEngineReactnative.default.instance().on('audioRouteChange', audioRoute => {
    (0, _logger.zloginfo)('[audioRouteChange callback]', audioRoute);
    _onAudioRouteChange(audioRoute);
  });
  _zegoExpressEngineReactnative.default.instance().on('IMRecvBroadcastMessage', (roomID, messageList) => {
    _onInRoomMessageReceived(roomID, messageList);
  });
  _zegoExpressEngineReactnative.default.instance().on('roomTokenWillExpire', (roomID, remainTimeInSecond) => {
    (0, _logger.zloginfo)('express token will expire.');
    _onRequireNewToken();
  });
  _zegoExpressEngineReactnative.default.instance().on('roomExtraInfoUpdate', (roomID, roomExtraInfoList) => {
    _onRoomExtraInfoUpdate(roomID, roomExtraInfoList);
  });
  _zegoExpressEngineReactnative.default.instance().on('roomStreamExtraInfoUpdate', (roomID, streamList) => {
    (0, _logger.zloginfo)('roomStreamExtraInfoUpdate', streamList);
    streamList.forEach(stream => {
      parseStreamExtraInfo(stream);
    });
  });
  _zegoExpressEngineReactnative.default.instance().on('IMRecvCustomCommand', (roomID, fromUser, command) => {
    (0, _logger.zloginfo)('IMRecvCustomCommand', roomID, fromUser, command);
    _onIMCustomCommandReceived(roomID, fromUser, command);
  });
  _zegoExpressEngineReactnative.default.instance().on('playerVideoSizeChanged', (streamID, width, height) => {
    (0, _logger.zloginfo)('playerVideoSizeChanged', streamID, width, height);
    const userID = _streamCoreUserMap[streamID].userID;
    _coreUserMap[userID].isLandscape = width > height;
    ZegoUIKitInternal.forceRenderVideoView();
  });
  _zegoExpressEngineReactnative.default.instance().on('publisherVideoSizeChanged', (width, height, channel) => {
    (0, _logger.zloginfo)('publisherVideoSizeChanged', width, height, channel);
    _localCoreUser.isLandscape = width > height;
    if (_currentRoomID) {
      // _coreUserMap will be fill after entering the room.
      _coreUserMap[_localCoreUser.userID].isLandscape = width > height;
    }
    ZegoUIKitInternal.forceRenderVideoView();
  });
  _zegoExpressEngineReactnative.default.instance().on('engineStateUpdate', state => {
    (0, _logger.zloginfo)('[engineStateUpdate callback]', (0, _enum_name.getZegoEngineStateName)(state));
    _engineState = state;
  });
}
function _unregisterEngineCallback() {
  (0, _logger.zloginfo)('Unregister callback from ZegoExpressEngine...');
  _zegoExpressEngineReactnative.default.instance().off('roomUserUpdate', undefined);
  _zegoExpressEngineReactnative.default.instance().off('roomStreamUpdate', undefined);
  _zegoExpressEngineReactnative.default.instance().off('publisherQualityUpdate', undefined);
  _zegoExpressEngineReactnative.default.instance().off('playerQualityUpdate', undefined);
  _zegoExpressEngineReactnative.default.instance().off('remoteCameraStateUpdate', undefined);
  _zegoExpressEngineReactnative.default.instance().off('remoteMicStateUpdate', undefined);
  _zegoExpressEngineReactnative.default.instance().off('playerStateUpdate', undefined);
  _zegoExpressEngineReactnative.default.instance().off('remoteSoundLevelUpdate', undefined);
  _zegoExpressEngineReactnative.default.instance().off('capturedSoundLevelUpdate', undefined);
  _zegoExpressEngineReactnative.default.instance().off('roomStateChanged', undefined);
  _zegoExpressEngineReactnative.default.instance().off('audioRouteChange', undefined);
  _zegoExpressEngineReactnative.default.instance().off('IMRecvBroadcastMessage', undefined);
  _zegoExpressEngineReactnative.default.instance().off('roomTokenWillExpire', undefined);
  _zegoExpressEngineReactnative.default.instance().off('roomExtraInfoUpdate', undefined);
  _zegoExpressEngineReactnative.default.instance().off('roomStreamExtraInfoUpdate', undefined);
  _zegoExpressEngineReactnative.default.instance().off('IMRecvCustomCommand', undefined);
  _zegoExpressEngineReactnative.default.instance().off('playerVideoSizeChanged', undefined);
  _zegoExpressEngineReactnative.default.instance().off('publisherVideoSizeChanged', undefined);
  _zegoExpressEngineReactnative.default.instance().off('engineStateUpdate', undefined);
}
function _notifyUserCountOrPropertyChanged(type) {
  const msg = ['', 'user add', 'user delete', 'mic update', 'camera update', 'attributes update'];
  const userList = Object.values(_coreUserMap).sort((user1, user2) => {
    return user2.joinTime - user1.joinTime;
  }).map(user => _createPublicUser(user));
  (0, _logger.zloginfo)(`_notifyUserCountOrPropertyChanged ${msg[type]}, retain users: `, userList);
  Object.keys(_onUserCountOrPropertyChangedCallbackMap).forEach(callbackID => {
    if (_onUserCountOrPropertyChangedCallbackMap[callbackID]) {
      _onUserCountOrPropertyChangedCallbackMap[callbackID](JSON.parse(JSON.stringify(userList)));
    }
  });
}

// >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> Stream Handling <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
function _getUserIDByStreamID(streamID) {
  // StreamID format: roomid_userid_main
  for (const userID in _coreUserMap) {
    if (_coreUserMap[userID].streamID == streamID) {
      return userID;
    }
  }
  return '';
}
function _getPublishStreamID() {
  return _currentRoomID + '_' + _localCoreUser.userID + '_main';
}
function _getStreamIDByUserID(userID) {
  return _currentRoomID + '_' + userID + '_main';
}
function _getScreenshareStreamIDByUserID(userID) {
  return _currentRoomID + '_' + userID + _screenshareStreamIDFlag;
}
function parseStreamExtraInfo(stream) {
  try {
    var extraInfo = JSON.parse(stream.extraInfo);
    if ('isCameraOn' in extraInfo) {
      _onRemoteCameraStateUpdate(stream.user.userID, extraInfo.isCameraOn);
    }
    if ('isMicrophoneOn' in extraInfo) {
      _onRemoteMicStateUpdate(stream.user.userID, extraInfo.isMicrophoneOn);
    }
  } catch (error) {
    (0, _logger.zlogerror)('parse streamExtraInfo ERROR: ', error);
  }
}
function _tryStartPublishStream() {
  if (_localCoreUser.isMicDeviceOn || _localCoreUser.isCameraDeviceOn) {
    (0, _logger.zloginfo)('_tryStartPublishStream', ', mic:', _localCoreUser.isMicDeviceOn, ', camera:', _localCoreUser.isCameraDeviceOn, _localCoreUser.streamID);
    if (_localCoreUser.streamID) {
      _zegoExpressEngineReactnative.default.instance().startPublishingStream(_localCoreUser.streamID, _zegoExpressEngineReactnative.ZegoPublishChannel.Main, undefined).then(() => {
        (0, _logger.zloginfo)('Notify local user audioVideoAvailable start', _localCoreUser.streamID + '', JSON.parse(JSON.stringify(_streamCoreUserMap)));
        // if (_localCoreUser.streamID in _streamCoreUserMap) {
        _streamCoreUserMap[_localCoreUser.streamID] = _localCoreUser;
        (0, _logger.zloginfo)('Notify local user audioVideoAvailable end', _localCoreUser);
        _notifyAudioVideoAvailable([_localCoreUser]);
        // }
      });
    }
    if (_localCoreUser.viewID > 0 && _localCoreUser.isCameraDeviceOn) {
      (0, _logger.zloginfo)('ZegoExpressEngine startPreview:', _localCoreUser);
      _zegoExpressEngineReactnative.default.instance().startPreview({
        reactTag: _localCoreUser.viewID,
        viewMode: _localCoreUser.fillMode,
        backgroundColor: 0
      }, _zegoExpressEngineReactnative.ZegoPublishChannel.Main).catch(error => {
        (0, _logger.zlogerror)(error);
      });
    }
  }
}
function _tryStopPublishStream(force = false) {
  if (!_localCoreUser.isMicDeviceOn && !_localCoreUser.isCameraDeviceOn) {
    (0, _logger.zloginfo)('stopPublishStream stopPreview');
    try {
      _zegoExpressEngineReactnative.default.instance().stopPublishingStream(_zegoExpressEngineReactnative.ZegoPublishChannel.Main);
      _zegoExpressEngineReactnative.default.instance().stopPreview(_zegoExpressEngineReactnative.ZegoPublishChannel.Main);
    } catch (e) {
      (0, _logger.zloginfo)('stopPublishStream stopPreview, but expressengine is null');
    }
    if (_localCoreUser.streamID in _streamCoreUserMap) {
      delete _streamCoreUserMap[_localCoreUser.streamID];
      _notifyAudioVideoUnavailable([_localCoreUser]);
    }
  }
}
function _tryStartPlayStream(userID) {
  if (userID in _coreUserMap) {
    const user = _coreUserMap[userID];
    (0, _logger.zloginfo)(`[_tryStartPlayStream] userID: ${user.userID}, viewID: ${user.viewID}, fillMode: ${user.fillMode}, resourceMode: ${_audioVideoResourceMode}`);

    // Playing Streaming.
    if (user.streamID !== '') {
      if (user.viewID > 0) {
        _zegoExpressEngineReactnative.default.instance().startPlayingStream(user.streamID, {
          reactTag: user.viewID,
          viewMode: user.fillMode,
          backgroundColor: 0
        }, {
          resourceMode: _audioVideoResourceMode
        }).then(() => {}).catch(error => {
          (0, _logger.zlogerror)(`startPlayingStream fail, stream: ${user.streamID}`);
        });
      } else {
        _zegoExpressEngineReactnative.default.instance().startPlayingStream(user.streamID, undefined, {
          resourceMode: _audioVideoResourceMode
        }).then(() => {}).catch(error => {
          (0, _logger.zlogerror)(`startPlayingStream fail, stream: ${user.streamID}`);
        });
      }
    }

    // Playing Screenshare Streaming.
    if (user.screenshareStreamID !== '' && user.screenshareViewID > 0) {
      _zegoExpressEngineReactnative.default.instance().startPlayingStream(user.screenshareStreamID, {
        reactTag: user.screenshareViewID,
        viewMode: user.screenshareViewFillMode,
        backgroundColor: 0
      }, {
        resourceMode: _audioVideoResourceMode
      });
    }
  }
}
function _tryStopPlayStream(userID, force = false) {
  (0, _logger.zloginfo)(`[_tryStopPlayStream] userID: ${userID}`);
  if (userID in _coreUserMap) {
    const user = _coreUserMap[userID];
    if (force || !user.isMicDeviceOn && !user.isCameraDeviceOn) {
      _zegoExpressEngineReactnative.default.instance().stopPlayingStream(user.streamID);
    }
  }
}
function _tryStopPlayScreenshareStream(userID) {
  if (userID in _coreUserMap) {
    const user = _coreUserMap[userID];
    if (user.screenshareStreamID !== '') {
      _zegoExpressEngineReactnative.default.instance().stopPlayingStream(user.screenshareStreamID);
    }
  }
}
function _notifyUserInfoUpdate(userInfo) {
  Object.keys(_onUserInfoUpdateCallbackMap).forEach(callbackID => {
    if (_onUserInfoUpdateCallbackMap[callbackID]) {
      _onUserInfoUpdateCallbackMap[callbackID](userInfo);
    }
  });
}
function _notifySoundLevelUpdate(userID, soundLevel) {
  Object.keys(_onSoundLevelUpdateCallbackMap).forEach(callbackID => {
    if (_onSoundLevelUpdateCallbackMap[callbackID]) {
      _onSoundLevelUpdateCallbackMap[callbackID](userID, soundLevel);
    }
  });
}
function _notifyRoomPropertyUpdate(key, oldValue, value, type) {
  Object.keys(_onRoomPropertyUpdatedCallbackMap).forEach(callbackID => {
    if (_onRoomPropertyUpdatedCallbackMap[callbackID]) {
      _onRoomPropertyUpdatedCallbackMap[callbackID](key, oldValue, value, type);
    }
  });
}
function _notifyRoomPropertiesFullUpdate(keys, oldRoomProperties, roomProperties, type) {
  Object.keys(_onRoomPropertiesFullUpdatedCallbackMap).forEach(callbackID => {
    if (_onRoomPropertiesFullUpdatedCallbackMap[callbackID]) {
      _onRoomPropertiesFullUpdatedCallbackMap[callbackID](keys, oldRoomProperties, roomProperties, type);
    }
  });
}
function _notifyMeRemovedFromRoom() {
  Object.keys(_onMeRemovedFromRoomCallbackMap).forEach(callbackID => {
    if (_onMeRemovedFromRoomCallbackMap[callbackID]) {
      _onMeRemovedFromRoomCallbackMap[callbackID]();
    }
  });
}
function _notifyJoinRoom() {
  Object.keys(_onJoinRoomCallbackMap).forEach(callbackID => {
    if (_onJoinRoomCallbackMap[callbackID]) {
      _onJoinRoomCallbackMap[callbackID]();
    }
  });
}
function _notifyAudioVideoAvailable(users) {
  Object.keys(_onAudioVideoAvailableCallbackMap).forEach(callbackID => {
    if (_onAudioVideoAvailableCallbackMap[callbackID]) {
      _onAudioVideoAvailableCallbackMap[callbackID](users);
    }
  });
}
function _notifyAudioVideoUnavailable(users) {
  Object.keys(_onAudioVideoUnavailableCallbackMap).forEach(callbackID => {
    if (_onAudioVideoUnavailableCallbackMap[callbackID]) {
      _onAudioVideoUnavailableCallbackMap[callbackID](users);
    }
  });
}
function _notifyScreenSharingAvailable(users) {
  Object.keys(_onScreenSharingAvailableCallbackMap).forEach(callbackID => {
    if (_onScreenSharingAvailableCallbackMap[callbackID]) {
      _onScreenSharingAvailableCallbackMap[callbackID](users);
    }
  });
}
function _notifyScreenSharingUnavailable(users) {
  Object.keys(_onScreenSharingUnavailableCallbackMap).forEach(callbackID => {
    if (_onScreenSharingUnavailableCallbackMap[callbackID]) {
      _onScreenSharingUnavailableCallbackMap[callbackID](users);
    }
  });
}
function _applyVideoConfig() {
  const config = _videoConfig.toSDK(_appOrientation);
  _zegoExpressEngineReactnative.default.instance().setVideoConfig(config, _zegoExpressEngineReactnative.ZegoPublishChannel.Main);
  (0, _logger.zloginfo)(`[setAppOrientation] express setVideoConfig:${JSON.stringify(config)}`);
}
const _isEngineCreated = () => {
  try {
    return _zegoExpressEngineReactnative.default.instance() != undefined;
  } catch (error) {
    return false;
  }
};
const ZegoUIKitInternal = {
  // >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> Internal <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  getPackageVersion() {
    return (0, _package_version.getPackageVersion)();
  },
  logComponentsVersion(extraInfo) {
    (0, _version.logComponentsVersion)(extraInfo);
  },
  isRoomConnected() {
    return _isRoomConnected;
  },
  setAudioVideoResourceMode(audioVideoResourceMode) {
    (0, _logger.zloginfo)('setAudioVideoResourceMode', audioVideoResourceMode);
    _audioVideoResourceMode = audioVideoResourceMode || _defines.ZegoAudioVideoResourceMode.Default;
  },
  updateRenderingProperty(userID, viewID, lastViewID, fillMode, isScreenshare = false) {
    (0, _logger.zloginfo)(`[updateRenderingProperty] userID: ${userID}, viewID: ${viewID}, lastViewID: ${lastViewID}, fillMode: ${fillMode}, isScreenshare: ${isScreenshare}`);
    if (userID === undefined) {
      (0, _logger.zlogwarning)('updateRenderingProperty: ignore undefined useid. Use empty string for local user.');
      return;
    }
    if (userID === '') {
      userID = _localCoreUser.userID;
    }
    if (userID in _coreUserMap) {
      // Avoid issues when the stream is handed over between two views.
      let canUpdateViewID = true;
      if (viewID <= 0) {
        if (isScreenshare) {
          canUpdateViewID = lastViewID === _coreUserMap[userID].screenshareViewID;
        } else {
          canUpdateViewID = lastViewID === _coreUserMap[userID].viewID;
        }
      }
      if (canUpdateViewID) {
        if (isScreenshare) {
          _coreUserMap[userID].screenshareViewID = viewID;
          _coreUserMap[userID].screenshareViewFillMode = fillMode;
        } else {
          _coreUserMap[userID].viewID = viewID;
          _coreUserMap[userID].fillMode = fillMode;
        }
        _notifyUserInfoUpdate(_coreUserMap[userID]);
      } else {
        (0, _logger.zloginfo)('[updateRenderingProperty] can not update viewID');
      }
      if (_localCoreUser.userID == userID) {
        _localCoreUser.viewID = viewID;
        _localCoreUser.fillMode = fillMode;
        if (viewID > 0) {
          _tryStartPublishStream();
        } else {
          _tryStopPublishStream();
        }
      } else {
        // Check if stream is ready to play for remote user
        if (viewID > 0) {
          _tryStartPlayStream(userID);
        }
      }
    }
  },
  onUserInfoUpdate(callbackID, callback) {
    if (typeof callback !== 'function') {
      if (callbackID in _onUserInfoUpdateCallbackMap) {
        (0, _logger.zloginfo)('[onUserInfoUpdate] Remove callback for: [', callbackID, '] because callback is not a valid function!');
        delete _onUserInfoUpdateCallbackMap[callbackID];
      }
    } else {
      _onUserInfoUpdateCallbackMap[callbackID] = callback;
    }
  },
  onSoundLevelUpdate(callbackID, callback) {
    if (typeof callback !== 'function') {
      if (callbackID in _onSoundLevelUpdateCallbackMap) {
        (0, _logger.zloginfo)('[onSoundLevelUpdate] Remove callback for: [', callbackID, '] because callback is not a valid function!');
        delete _onSoundLevelUpdateCallbackMap[callbackID];
      }
    } else {
      _onSoundLevelUpdateCallbackMap[callbackID] = callback;
    }
  },
  onSDKConnected(callbackID, callback) {
    if (typeof callback !== 'function') {
      if (callbackID in _onSDKConnectedCallbackMap) {
        (0, _logger.zloginfo)('[onSDKConnected] Remove callback for: [', callbackID, '] because callback is not a valid function!');
        delete _onSDKConnectedCallbackMap[callbackID];
      }
    } else {
      _onSDKConnectedCallbackMap[callbackID] = callback;
    }
  },
  // >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> SDK <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  connectSDK(appID, appSign, userInfo) {
    // Solve the problem of repeated initialization
    if (_isEngineCreated()) {
      (0, _logger.zloginfo)('Create ZegoExpressEngine succeed already!');
      _unregisterEngineCallback();
      _registerEngineCallback();
      _applyVideoConfig();
      _localCoreUser.userID = userInfo.userID;
      _localCoreUser.userName = userInfo.userName;
      _coreUserMap[userInfo.userID] = _localCoreUser;
      Object.keys(_onSDKConnectedCallbackMap).forEach(callbackID => {
        // TODO cause  WARN  Possible Unhandled Promise Rejection (id: 56)
        if (_onSDKConnectedCallbackMap[callbackID]) {
          _onSDKConnectedCallbackMap[callbackID]();
        }
      });
      return Promise.resolve();
    }
    return new Promise((resolve, reject) => {
      // set advancedConfig to monitor remote user's device changed
      _zegoExpressEngineReactnative.default.setEngineConfig({
        advancedConfig: {
          // @ts-ignore
          notify_remote_device_unknown_status: 'true',
          notify_remote_device_init_status: 'true'
        }
      });
      const engineProfile = {
        appID: appID,
        appSign: appSign,
        scenario: 0
      };
      _report.default.create(appID, appSign, {
        'user_id': userInfo.userID
      });
      (0, _logger.zloginfo)(`[ZegoUIKitInternal][connectSDK] createEngine`);
      _zegoExpressEngineReactnative.default.createEngineWithProfile(engineProfile).then(engine => {
        (0, _logger.zloginfo)('Create ZegoExpressEngine succeed!');
        _appInfo.appID = appID;
        _appInfo.appSign = appSign;
        _unregisterEngineCallback();
        _registerEngineCallback();
        _applyVideoConfig();
        _setLocalUserInfo(userInfo);
        Object.keys(_onSDKConnectedCallbackMap).forEach(callbackID => {
          // TODO cause  WARN  Possible Unhandled Promise Rejection (id: 56)
          if (_onSDKConnectedCallbackMap[callbackID]) {
            _onSDKConnectedCallbackMap[callbackID]();
          }
        });
        resolve();
      }).catch(error => {
        (0, _logger.zlogerror)('Create ZegoExpressEngine Failed: ', error);
        reject(error);
      });
    });
  },
  disconnectSDK() {
    return new Promise((resolve, reject) => {
      (0, _logger.zloginfo)(`[ZegoUIKitInternal][disconnectSDK] destroyEngine`);
      if (_zegoExpressEngineReactnative.default.instance()) {
        _zegoExpressEngineReactnative.default.destroyEngine().then(() => {
          (0, _logger.zloginfo)('Destroy ZegoExpressEngine finished!');
          resolve();
        }).catch(error => {
          (0, _logger.zlogerror)('Destroy ZegoExpressEngine failed!', error);
          reject(error);
        }).finally(() => {
          _resetData();
        });
      } else {
        resolve();
      }
    });
  },
  // >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> Audio Video <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  useFrontFacingCamera(isFrontFacing) {
    (0, _logger.zloginfo)('UseFrontFacingCamera: ', isFrontFacing);
    _usingFrontFacingCamera = isFrontFacing;
    return _zegoExpressEngineReactnative.default.instance().useFrontCamera(isFrontFacing, 0);
  },
  isUsingFrontFacingCamera() {
    return _usingFrontFacingCamera;
  },
  isMicDeviceOn(userID) {
    if (!userID) {
      return _localCoreUser.isMicDeviceOn;
    } else if (userID in _coreUserMap) {
      return _coreUserMap[userID].isMicDeviceOn;
    } else {
      (0, _logger.zloginfo)('Can not check mic device is on for user[', userID, '], because no record!');
      return true;
    }
  },
  isCameraDeviceOn(userID) {
    if (!userID) {
      return _localCoreUser.isCameraDeviceOn;
    } else if (userID in _coreUserMap) {
      return _coreUserMap[userID].isCameraDeviceOn;
    } else {
      (0, _logger.zloginfo)('No record for user: ', userID, '. Can not check camera device is on.');
      return true;
    }
  },
  enableSpeaker(enable) {
    // TODO
    return new Promise((resolve, reject) => {
      if (!_isRoomConnected) {
        (0, _logger.zlogerror)('You are not connect to any room.');
        reject();
      } else {
        _zegoExpressEngineReactnative.default.instance().muteSpeaker(!enable);
        resolve();
      }
    });
  },
  audioOutputDeviceType() {
    return _audioOutputType;
  },
  turnMicDeviceOn(userID, on) {
    return _turnMicDeviceOn(userID, on);
  },
  turnCameraDeviceOn(userID, on) {
    return _turnCameraDeviceOn(userID, on);
  },
  onMicDeviceOn(callbackID, callback) {
    if (typeof callback !== 'function') {
      if (callbackID in _onMicDeviceOnCallbackMap) {
        (0, _logger.zloginfo)('[onMicDeviceOn] Remove callback for: [', callbackID, '] because callback is not a valid function!');
        delete _onMicDeviceOnCallbackMap[callbackID];
      }
    } else {
      _onMicDeviceOnCallbackMap[callbackID] = callback;
    }
  },
  onCameraDeviceOn(callbackID, callback) {
    if (typeof callback !== 'function') {
      if (callbackID in _onCameraDeviceOnCallbackMap) {
        (0, _logger.zloginfo)('[onCameraDeviceOn] Remove callback for: [', callbackID, '] because callback is not a valid function!');
        delete _onCameraDeviceOnCallbackMap[callbackID];
      }
    } else {
      _onCameraDeviceOnCallbackMap[callbackID] = callback;
    }
  },
  setAudioOutputToSpeaker(isSpeaker) {
    _zegoExpressEngineReactnative.default.instance().setAudioRouteToSpeaker(isSpeaker);
  },
  onAudioOutputDeviceTypeChange(callbackID, callback) {
    if (typeof callback !== 'function') {
      if (callbackID in _onAudioOutputDeviceTypeChangeCallbackMap) {
        (0, _logger.zloginfo)('[onAudioOutputDeviceTypeChange] Remove callback for: [', callbackID, '] because callback is not a valid function!');
        delete _onAudioOutputDeviceTypeChangeCallbackMap[callbackID];
      }
    } else {
      _onAudioOutputDeviceTypeChangeCallbackMap[callbackID] = callback;
    }
  },
  setAudioConfig(config) {
    // TODO
  },
  //  setAppOrientation 
  setVideoConfig(config) {
    (0, _logger.zloginfo)(`[setVideoConfig] videoConfig:${JSON.stringify(config)}`);
    _videoConfig = config;
  },
  setAppOrientation(orientation) {
    (0, _logger.zloginfo)(`[setAppOrientation] orientation:${orientation}`);
    _appOrientation = orientation;
    if (_localCoreUser) {
      _localCoreUser.isLandscape = _appOrientation !== 0;
    }
    if (_coreUserMap[_localCoreUser.userID]) {
      _coreUserMap[_localCoreUser.userID].isLandscape = _appOrientation !== 0;
    }
    if (_isEngineCreated()) {
      if (_engineState === _zegoExpressEngineReactnative.ZegoEngineState.Stop) {
        _applyVideoConfig();
      } else {
        (0, _logger.zloginfo)(`[setAppOrientation] engineState is Start, can't apply video config`);
      }
      _zegoExpressEngineReactnative.default.instance().setAppOrientation(_appOrientation, _zegoExpressEngineReactnative.ZegoPublishChannel.Main);
      (0, _logger.zloginfo)(`[setAppOrientation] express setAppOrientation:${_appOrientation}, engineState:${(0, _enum_name.getZegoEngineStateName)(_engineState)}`);
    }
  },
  appOrientation() {
    return _appOrientation;
  },
  onAudioVideoAvailable(callbackID, callback) {
    if (typeof callback !== 'function') {
      if (callbackID in _onAudioVideoAvailableCallbackMap) {
        (0, _logger.zloginfo)('[onAudioVideoAvailable] Remove callback for: [', callbackID, '] because callback is not a valid function!');
        delete _onAudioVideoAvailableCallbackMap[callbackID];
      }
    } else {
      _onAudioVideoAvailableCallbackMap[callbackID] = callback;
    }
  },
  onAudioVideoUnavailable(callbackID, callback) {
    if (typeof callback !== 'function') {
      if (callbackID in _onAudioVideoUnavailableCallbackMap) {
        (0, _logger.zloginfo)('[onAudioVideoUnavailable] Remove callback for: [', callbackID, '] because callback is not a valid function!');
        delete _onAudioVideoUnavailableCallbackMap[callbackID];
      }
    } else {
      _onAudioVideoUnavailableCallbackMap[callbackID] = callback;
    }
  },
  muteUserAudio(userID, mute) {
    const user = _coreUserMap[userID];
    (0, _logger.zloginfo)('[muteUserAudio]', userID, user.streamID, mute);
    if (user.streamID) {
      _zegoExpressEngineReactnative.default.instance().mutePlayStreamAudio(user.streamID, mute);
    }
  },
  muteUserVideo(userID, mute) {
    const user = _coreUserMap[userID];
    (0, _logger.zloginfo)('[muteUserVideo]', userID, user.streamID, mute);
    if (user.streamID) {
      _zegoExpressEngineReactnative.default.instance().mutePlayStreamVideo(user.streamID, mute);
    }
  },
  startPlayingAllAudioVideo() {
    _zegoExpressEngineReactnative.default.instance().muteAllPlayStreamAudio(false);
    _zegoExpressEngineReactnative.default.instance().muteAllPlayStreamVideo(false);
  },
  stopPlayingAllAudioVideo() {
    _zegoExpressEngineReactnative.default.instance().muteAllPlayStreamAudio(true);
    _zegoExpressEngineReactnative.default.instance().muteAllPlayStreamVideo(true);
  },
  onTurnOnYourCameraRequest(callbackID, callback) {
    if (typeof callback !== 'function') {
      if (callbackID in _onTurnOnYourCameraRequestCallbackMap) {
        (0, _logger.zloginfo)('[onTurnOnYourCameraRequest] Remove callback for: [', callbackID, '] because callback is not a valid function!');
        delete _onTurnOnYourCameraRequestCallbackMap[callbackID];
      }
    } else {
      _onTurnOnYourCameraRequestCallbackMap[callbackID] = callback;
    }
  },
  onTurnOnYourMicrophoneRequest(callbackID, callback) {
    if (typeof callback !== 'function') {
      if (callbackID in _onTurnOnYourMicrophoneRequestCallbackMap) {
        (0, _logger.zloginfo)('[onTurnOnYourMicrophoneRequest] Remove callback for: [', callbackID, '] because callback is not a valid function!');
        delete _onTurnOnYourMicrophoneRequestCallbackMap[callbackID];
      }
    } else {
      _onTurnOnYourMicrophoneRequestCallbackMap[callbackID] = callback;
    }
  },
  // >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> Room <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  async joinRoom(roomID, token, markAsLargeRoom = false) {
    if (!roomID || roomID.trim().length == 0) {
      throw new Error("roomID can't is empty when loginRoom!");
    }

    // Solve the problem of repeated join
    if (_isRoomConnected && _currentRoomID === roomID) {
      (0, _logger.zloginfo)(`Join room: ${roomID} success already.`);
      return Promise.resolve();
    }
    if (_appInfo.appSign === '' && token === '') {
      token = await ZegoUIKitInternal.getToken();
    }
    _zegoExpressEngineReactnative.default.instance().logoutRoom(undefined);
    return new Promise((resolve, reject) => {
      const user = {
        userID: _localCoreUser.userID,
        userName: _localCoreUser.userName
      };
      const config = {
        isUserStatusNotify: true
      };
      token && (config.token = token);
      _currentRoomID = roomID;
      const eventBegin = Date.now();
      (0, _logger.zloginfo)(`[ZegoUIKitInternal][joinRoom] loginRoom, roomID: ${roomID}`);
      _zegoExpressEngineReactnative.default.instance().loginRoom(roomID, user, config).then(() => {
        (0, _logger.zloginfo)(`Join room: ${roomID} success. ${JSON.stringify(user)}`);
        _report.default.reportEvent('loginRoom', {
          'room_id': roomID,
          'error': 0,
          'msg': '',
          'start_time': eventBegin
        });
        _roomMemberCount = 1;
        _markAsLargeRoom = markAsLargeRoom;
        _zegoExpressEngineReactnative.default.instance().startSoundLevelMonitor(undefined);
        _localCoreUser.streamID = _getPublishStreamID();
        _coreUserMap[_localCoreUser.userID] = _localCoreUser;
        _notifyUserCountOrPropertyChanged(_defines.ZegoChangedCountOrProperty.userAdd);
        _tryStartPublishStream();
        _notifyJoinRoom();
        resolve();
      }).catch(error => {
        (0, _logger.zlogerror)('Join room falied: ', error);
        _report.default.reportEvent('loginRoom', {
          'room_id': roomID,
          'error': -1,
          'msg': JSON.stringify(error),
          'start_time': eventBegin
        });
        _currentRoomID = '';
        reject(error);
      });
    });
  },
  inRoom() {
    return _currentRoomID.length > 0;
  },
  leaveRoom() {
    return _leaveRoom();
  },
  onRoomStateChanged(callbackID, callback) {
    if (typeof callback !== 'function') {
      if (callbackID in _onRoomStateChangedCallbackMap) {
        (0, _logger.zloginfo)('[onRoomStateChanged] Remove callback for: [', callbackID, '] because callback is not a valid function!');
        delete _onRoomStateChangedCallbackMap[callbackID];
      }
    } else {
      _onRoomStateChangedCallbackMap[callbackID] = callback;
    }
  },
  onRequireNewToken(callbackID, callback) {
    if (typeof callback !== 'function') {
      if (callbackID in _onRequireNewTokenCallbackMap) {
        (0, _logger.zloginfo)('[onRequireNewToken] Remove callback for: [', callbackID, '] because callback is not a valid function!');
        delete _onRequireNewTokenCallbackMap[callbackID];
      }
    } else {
      _onRequireNewTokenCallbackMap[callbackID] = callback;
    }
  },
  setRoomProperty(key, value) {
    if (!_isRoomConnected) {
      (0, _logger.zlogerror)('You need to join the room before using this interface!');
      return;
    }
    if (_roomProperties[key] === value) {
      return;
    }
    const oldValue = _roomProperties[key];
    const oldRoomProperties = JSON.parse(JSON.stringify(_roomProperties));
    _roomProperties[key] = value;
    const extraInfo = JSON.stringify(_roomProperties);
    (0, _logger.zloginfo)('[updateRoomProperties]Set start', extraInfo);
    return new Promise((resolve, reject) => {
      _zegoExpressEngineReactnative.default.instance().setRoomExtraInfo(_currentRoomID, 'extra_info', extraInfo).then(({
        errorCode
      }) => {
        if (errorCode === 0) {
          (0, _logger.zloginfo)('[updateRoomProperties]Set success');
          resolve();
          // Notify
          _notifyRoomPropertyUpdate(key, oldValue, value, _defines.ZegoRoomPropertyUpdateType.set);
          _notifyRoomPropertiesFullUpdate([key], oldRoomProperties, JSON.parse(extraInfo), _defines.ZegoRoomPropertyUpdateType.set);
        } else {
          // Restore
          _roomProperties = JSON.parse(JSON.stringify(oldRoomProperties));
          (0, _logger.zlogwarning)('[setRoomProperty]Set failed, errorCode: ', errorCode);
          reject({
            code: errorCode
          });
        }
      }).catch(error => {
        // Restore
        _roomProperties = JSON.parse(JSON.stringify(oldRoomProperties));
        (0, _logger.zlogerror)('[setRoomProperty]Set error', error);
        reject(error);
      });
    });
  },
  updateRoomProperties(newRoomProperties) {
    if (!_isRoomConnected) {
      (0, _logger.zlogerror)('You need to join the room before using this interface!');
      return Promise.reject();
    }
    const updateKeys = [];
    const oldRoomProperties = JSON.parse(JSON.stringify(_roomProperties));
    Object.keys(newRoomProperties).forEach(key => {
      if (oldRoomProperties[key] !== newRoomProperties[key]) {
        updateKeys.push(key);
        _roomProperties[key] = newRoomProperties[key];
      }
    });
    const extraInfo = JSON.stringify(_roomProperties);
    (0, _logger.zloginfo)('[updateRoomProperties]Update start', extraInfo);
    return new Promise((resolve, reject) => {
      _zegoExpressEngineReactnative.default.instance().setRoomExtraInfo(_currentRoomID, 'extra_info', extraInfo).then(({
        errorCode
      }) => {
        if (errorCode === 0) {
          (0, _logger.zloginfo)('[updateRoomProperties]Update success');
          resolve();
          // Notify
          updateKeys.forEach(updateKey => {
            const oldValue = oldRoomProperties[updateKey];
            const value = newRoomProperties[updateKey];
            _notifyRoomPropertyUpdate(updateKey, oldValue, value, _defines.ZegoRoomPropertyUpdateType.update);
          });
          updateKeys.length && _notifyRoomPropertiesFullUpdate(updateKeys, oldRoomProperties, JSON.parse(extraInfo), _defines.ZegoRoomPropertyUpdateType.update);
        } else {
          // Restore
          _roomProperties = JSON.parse(JSON.stringify(oldRoomProperties));
          (0, _logger.zlogwarning)('[updateRoomProperties]Update failed, errorCode: ', errorCode);
          reject({
            code: errorCode
          });
        }
      }).catch(error => {
        // Restore
        _roomProperties = JSON.parse(JSON.stringify(oldRoomProperties));
        (0, _logger.zlogerror)('[updateRoomProperties]Update error', error);
        reject(error);
      });
    });
  },
  getRoomProperties() {
    return _roomProperties;
  },
  onRoomPropertyUpdated(callbackID, callback) {
    if (typeof callback !== 'function') {
      if (callbackID in _onRoomPropertyUpdatedCallbackMap) {
        (0, _logger.zloginfo)('[onRoomPropertyUpdated] Remove callback for: [', callbackID, '] because callback is not a valid function!');
        delete _onRoomPropertyUpdatedCallbackMap[callbackID];
      }
    } else {
      _onRoomPropertyUpdatedCallbackMap[callbackID] = callback;
    }
  },
  onRoomPropertiesFullUpdated(callbackID, callback) {
    if (typeof callback !== 'function') {
      if (callbackID in _onRoomPropertiesFullUpdatedCallbackMap) {
        (0, _logger.zloginfo)('[onRoomPropertiesFullUpdated] Remove callback for: [', callbackID, '] because callback is not a valid function!');
        delete _onRoomPropertiesFullUpdatedCallbackMap[callbackID];
      }
    } else {
      _onRoomPropertiesFullUpdatedCallbackMap[callbackID] = callback;
    }
  },
  sendInRoomCommand(command, toUserIDs = []) {
    const toUserList = toUserIDs.map(userID => {
      const userInfo = _coreUserMap[userID];
      const userName = userInfo ? userInfo.userName || '' : '';
      return {
        userID,
        userName
      };
    });
    return _sendInRoomCommand(command, toUserList);
  },
  onInRoomCommandReceived(callbackID, callback) {
    if (typeof callback !== 'function') {
      if (callbackID in _onInRoomCommandReceivedCallbackMap) {
        (0, _logger.zloginfo)('[onInRoomCommandReceived] Remove callback for: [', callbackID, '] because callback is not a valid function!');
        delete _onInRoomCommandReceivedCallbackMap[callbackID];
      }
    } else {
      _onInRoomCommandReceivedCallbackMap[callbackID] = callback;
    }
  },
  onMeRemovedFromRoom(callbackID, callback) {
    if (typeof callback !== 'function') {
      if (callbackID in _onMeRemovedFromRoomCallbackMap) {
        (0, _logger.zloginfo)('[onMeRemovedFromRoom] Remove callback for: [', callbackID, '] because callback is not a valid function!');
        delete _onMeRemovedFromRoomCallbackMap[callbackID];
      }
    } else {
      _onMeRemovedFromRoomCallbackMap[callbackID] = callback;
    }
  },
  onJoinRoom(callbackID, callback) {
    if (typeof callback !== 'function') {
      if (callbackID in _onJoinRoomCallbackMap) {
        (0, _logger.zloginfo)('[onJoinRoom] Remove callback for: [', callbackID, '] because callback is not a valid function!');
        delete _onJoinRoomCallbackMap[callbackID];
      }
    } else {
      _onJoinRoomCallbackMap[callbackID] = callback;
    }
  },
  // >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> User <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  connectUser(userID, userName) {
    _setLocalUserInfo({
      userID: userID,
      userName: userName
    });
    // TODO ZIM login
  },
  disconnectUser() {
    delete _coreUserMap[_localCoreUser.userID];
    _localCoreUser = _createCoreUser('', '', '', {});
    // TODO ZIM logout
  },
  getLocalUserInfo() {
    return _localCoreUser;
  },
  getUser(userID) {
    return _coreUserMap[userID];
  },
  getAllScreenshareUsers() {
    var users = [];
    Object.keys(_streamCoreUserMap).forEach(streamID => {
      const isScreenshare = streamID.endsWith(_screenshareStreamIDFlag);
      if (isScreenshare) {
        users.push(_streamCoreUserMap[streamID]);
      }
    });
    return users;
  },
  getAllUsers() {
    const users = Object.values(_coreUserMap);
    users.sort((a, b) => {
      return a.joinTime - b.joinTime;
    });
    var publicUsers = [];
    users.forEach(user => {
      publicUsers.push(_createPublicUser(user));
    });
    return publicUsers;
  },
  getAudioVideoUsers() {
    const users = Object.values(_streamCoreUserMap);
    users.sort((a, b) => {
      return a.joinTime - b.joinTime;
    });
    var publicUsers = [];
    users.forEach(user => {
      publicUsers.push(_createPublicUser(user));
    });
    return publicUsers;
  },
  onUserJoin(callbackID, callback) {
    if (typeof callback !== 'function') {
      if (callbackID in _onUserJoinCallbackMap) {
        (0, _logger.zloginfo)('[onUserJoin] Remove callback for: [', callbackID, '] because callback is not a valid function!');
        delete _onUserJoinCallbackMap[callbackID];
      }
    } else {
      _onUserJoinCallbackMap[callbackID] = callback;
    }
  },
  onUserLeave(callbackID, callback) {
    if (typeof callback !== 'function') {
      if (callbackID in _onUserLeaveCallbackMap) {
        (0, _logger.zloginfo)('[onUserLeave] Remove callback for: [', callbackID, '] because callback is not a valid function!');
        delete _onUserLeaveCallbackMap[callbackID];
      }
    } else {
      _onUserLeaveCallbackMap[callbackID] = callback;
    }
  },
  onOnlySelfInRoom(callbackID, callback) {
    if (typeof callback !== 'function') {
      if (callbackID in _onOnlySelfInRoomCallbackMap) {
        (0, _logger.zloginfo)('[onOnlySelfInRoom] Remove callback for: [', callbackID, '] because callback is not a valid function!');
        delete _onOnlySelfInRoomCallbackMap[callbackID];
      }
    } else {
      _onOnlySelfInRoomCallbackMap[callbackID] = callback;
    }
  },
  onUserCountOrPropertyChanged(callbackID, callback) {
    if (typeof callback !== 'function') {
      if (callbackID in _onUserCountOrPropertyChangedCallbackMap) {
        (0, _logger.zloginfo)('[onUserCountOrPropertyChanged] Remove callback for: [', callbackID, '] because callback is not a valid function!');
        delete _onUserCountOrPropertyChangedCallbackMap[callbackID];
      }
    } else {
      _onUserCountOrPropertyChangedCallbackMap[callbackID] = callback;
    }
  },
  removeUserFromRoom(userIDs = []) {
    const command = JSON.stringify({
      zego_remove_user: userIDs
    });
    const toUserList = _isLargeRoom || _markAsLargeRoom ? [] : userIDs.map(userID => {
      const userInfo = _coreUserMap[userID];
      const userName = userInfo ? userInfo.userName || '' : '';
      return {
        userID,
        userName
      };
    });
    return _sendInRoomCommand(command, toUserList);
  },
  // >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> Message <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  getInRoomMessages() {
    return _inRoomMessageList;
  },
  sendInRoomMessage(message) {
    return new Promise((resolve, reject) => {
      _zegoExpressEngineReactnative.default.instance().sendBroadcastMessage(_currentRoomID, message).then(result => {
        (0, _logger.zloginfo)('SendInRoomMessage finished.', result);
        const {
          errorCode,
          messageID
        } = result;
        if (errorCode > 0) {
          reject(errorCode);
        } else {
          const inRoomMessage = {
            type: 'user',
            message: message,
            messageID: messageID,
            sendTime: Date.now(),
            sender: _createPublicUser(_localCoreUser)
          };
          _inRoomMessageList.push(inRoomMessage);
          Object.keys(_onInRoomMessageSentCallbackMap).forEach(callbackID => {
            // callback may remove from map during room state chaging
            if (callbackID in _onInRoomMessageSentCallbackMap) {
              if (_onInRoomMessageSentCallbackMap[callbackID]) {
                _onInRoomMessageSentCallbackMap[callbackID](errorCode, messageID);
              }
            }
          });
          resolve(result);
        }
      }).catch(error => {
        (0, _logger.zlogerror)('SendInRoomMessage falied: ', error);
        reject(error);
      });
    });
  },
  onInRoomMessageReceived(callbackID, callback) {
    if (typeof callback !== 'function') {
      if (callbackID in _onInRoomMessageReceivedCallbackMap) {
        (0, _logger.zloginfo)('[onInRoomMessageReceived] Remove callback for: [', callbackID, '] because callback is not a valid function!');
        delete _onInRoomMessageReceivedCallbackMap[callbackID];
      }
    } else {
      _onInRoomMessageReceivedCallbackMap[callbackID] = callback;
    }
  },
  onInRoomMessageSent(callbackID, callback) {
    if (typeof callback !== 'function') {
      if (callbackID in _onInRoomMessageSentCallbackMap) {
        (0, _logger.zloginfo)('[onInRoomMessageSent] Remove callback for: [', callbackID, '] because callback is not a valid function!');
        delete _onInRoomMessageSentCallbackMap[callbackID];
      }
    } else {
      _onInRoomMessageSentCallbackMap[callbackID] = callback;
    }
  },
  // >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> Live audio room <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  notifyUserCountOrPropertyChanged(type) {
    _notifyUserCountOrPropertyChanged(type);
  },
  notifyUserInfoUpdate(userID) {
    // Update avatar properties
    if (_coreUserMap[userID] && _coreUserMap[userID].inRoomAttributes) {
      _coreUserMap[userID].avatar = _coreUserMap[userID].inRoomAttributes.avatar;
    }
    _notifyUserInfoUpdate(_coreUserMap[userID]);
  },
  // >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> Force update component <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  forceSortMemberList() {
    (0, _logger.zloginfo)('[forceSortMemberList callback]');
    const userList = Object.values(_coreUserMap).sort((user1, user2) => {
      return user2.joinTime - user1.joinTime;
    }).map(user => _createPublicUser(user));
    Object.keys(_onMemberListForceSortCallbackMap).forEach(callbackID => {
      if (_onMemberListForceSortCallbackMap[callbackID]) {
        _onMemberListForceSortCallbackMap[callbackID](userList);
      }
    });
  },
  onMemberListForceSort(callbackID, callback) {
    if (typeof callback !== 'function') {
      if (callbackID in _onMemberListForceSortCallbackMap) {
        (0, _logger.zloginfo)('[onMemberListForceSort] Remove callback for: [', callbackID, '] because callback is not a valid function!');
        delete _onMemberListForceSortCallbackMap[callbackID];
      }
    } else {
      _onMemberListForceSortCallbackMap[callbackID] = callback;
    }
  },
  forceSortAudioVideoList() {
    (0, _logger.zloginfo)('[forceSortAudioVideoList callback]');
    Object.keys(_onAudioVideoListForceSortCallbackMap).forEach(callbackID => {
      if (_onAudioVideoListForceSortCallbackMap[callbackID]) {
        _onAudioVideoListForceSortCallbackMap[callbackID]();
      }
    });
  },
  onAudioVideoListForceSort(callbackID, callback) {
    if (typeof callback !== 'function') {
      if (callbackID in _onAudioVideoListForceSortCallbackMap) {
        (0, _logger.zloginfo)('[onAudioVideoListForceSort] Remove callback for: [', callbackID, '] because callback is not a valid function!');
        delete _onAudioVideoListForceSortCallbackMap[callbackID];
      }
    } else {
      _onAudioVideoListForceSortCallbackMap[callbackID] = callback;
    }
  },
  forceRenderVideoView() {
    (0, _logger.zloginfo)('[forceRenderVideoView callback]');
    Object.keys(_onVideoViewForceRenderCallbackMap).forEach(callbackID => {
      if (_onVideoViewForceRenderCallbackMap[callbackID]) {
        _onVideoViewForceRenderCallbackMap[callbackID]();
      }
    });
  },
  onVideoViewForceRender(callbackID, callback) {
    if (typeof callback !== 'function') {
      if (callbackID in _onVideoViewForceRenderCallbackMap) {
        (0, _logger.zloginfo)('[onVideoViewForceRender] Remove callback for: [', callbackID, '] because callback is not a valid function!');
        delete _onVideoViewForceRenderCallbackMap[callbackID];
      }
    } else {
      _onVideoViewForceRenderCallbackMap[callbackID] = callback;
    }
  },
  onError(callbackID, callback) {
    if (typeof callback !== 'function') {
      if (callbackID in _onErrorCallbackMap) {
        (0, _logger.zloginfo)('[onError] Remove callback for: [', callbackID, '] because callback is not a valid function!');
        delete _onErrorCallbackMap[callbackID];
      }
    } else {
      _onErrorCallbackMap[callbackID] = callback;
    }
  },
  notifyErrorUpdate(method, error, message) {
    Object.keys(_onErrorCallbackMap).forEach(callbackID => {
      if (_onErrorCallbackMap[callbackID]) {
        _onErrorCallbackMap[callbackID](method, error, message);
      }
    });
  },
  onTokenProvide(callback) {
    _onTokenProvideCallback = callback;
  },
  renewToken(token) {
    if (_isEngineCreated() && _currentRoomID) {
      _zegoExpressEngineReactnative.default.instance().renewToken(_currentRoomID, token).then(() => {
        (0, _logger.zloginfo)(`Renew token success, roomID: ${_currentRoomID}`);
      }).catch(error => {
        (0, _logger.zlogerror)('Renew token failed: ', error);
      });
    }
    return _invitation.default.renewToken(token);
  },
  async getToken() {
    if (typeof _onTokenProvideCallback !== 'function') {
      return '';
    }
    const token = await _onTokenProvideCallback();
    (0, _logger.zloginfo)(`[Get Token]: ${token}`);
    return token;
  },
  isScreenSharing() {
    Object.keys(_streamCoreUserMap).forEach(streamID => {
      if (streamID.endsWith(_screenshareStreamIDFlag)) {
        return true;
      }
    });
    return false;
  },
  onScreenSharingAvailable(callbackID, callback) {
    if (typeof callback !== 'function') {
      if (callbackID in _onScreenSharingAvailableCallbackMap) {
        (0, _logger.zloginfo)('[onScreenSharingAvailable] Remove callback for: [', callbackID, '] because callback is not a valid function!');
        delete _onScreenSharingAvailableCallbackMap[callbackID];
      }
    } else {
      _onScreenSharingAvailableCallbackMap[callbackID] = callback;
    }
  },
  onScreenSharingUnavailable(callbackID, callback) {
    if (typeof callback !== 'function') {
      if (callbackID in _onScreenSharingUnavailableCallbackMap) {
        (0, _logger.zloginfo)('[onScreenSharingAvailable] Remove callback for: [', callbackID, '] because callback is not a valid function!');
        delete _onScreenSharingUnavailableCallbackMap[callbackID];
      }
    } else {
      _onScreenSharingUnavailableCallbackMap[callbackID] = callback;
    }
  }
};
var _default = exports.default = ZegoUIKitInternal;
//# sourceMappingURL=ZegoUIKitInternal.js.map